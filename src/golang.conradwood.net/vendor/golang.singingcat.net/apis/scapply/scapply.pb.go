// Code generated by protoc-gen-go.
// source: golang.singingcat.net/apis/scapply/scapply.proto
// DO NOT EDIT!

/*
Package scapply is a generated protocol buffer package.

It is generated from these files:
	golang.singingcat.net/apis/scapply/scapply.proto

It has these top-level messages:
	Submissions
	Result
	SubmitRequest
	SubmitBatchMsg
	SubmitBatchRequest
	SubmitAttempt
	WaitRequest
	WaitResult
	CallbackItem
	CallbackResult
	CallbackQueueEntry
*/
package scapply

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import common "golang.conradwood.net/apis/common"
import singingcat "golang.singingcat.net/apis/singingcat"
import scmodcomms "golang.singingcat.net/apis/scmodcomms"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// the db proto to log submissions
type Submissions struct {
	ID                       uint64             `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	Submitted                uint32             `protobuf:"varint,2,opt,name=Submitted" json:"Submitted,omitempty"`
	ModuleID                 uint64             `protobuf:"varint,3,opt,name=ModuleID" json:"ModuleID,omitempty"`
	Type                     singingcat.ComType `protobuf:"varint,4,opt,name=Type,enum=singingcat.ComType" json:"Type,omitempty"`
	Key                      string             `protobuf:"bytes,5,opt,name=Key" json:"Key,omitempty"`
	Timeout                  uint32             `protobuf:"varint,6,opt,name=Timeout" json:"Timeout,omitempty"`
	ApplicationReference     uint64             `protobuf:"varint,7,opt,name=ApplicationReference" json:"ApplicationReference,omitempty"`
	LastAttempt              uint32             `protobuf:"varint,8,opt,name=LastAttempt" json:"LastAttempt,omitempty"`
	Attempts                 uint32             `protobuf:"varint,9,opt,name=Attempts" json:"Attempts,omitempty"`
	LastResult               uint32             `protobuf:"varint,10,opt,name=LastResult" json:"LastResult,omitempty"`
	SubmitRequest            string             `protobuf:"bytes,11,opt,name=SubmitRequest" json:"SubmitRequest,omitempty"`
	LastAnswerReceived       uint32             `protobuf:"varint,12,opt,name=LastAnswerReceived" json:"LastAnswerReceived,omitempty"`
	CompletionAnswerReceived uint32             `protobuf:"varint,13,opt,name=CompletionAnswerReceived" json:"CompletionAnswerReceived,omitempty"`
	Context                  []byte             `protobuf:"bytes,14,opt,name=Context,proto3" json:"Context,omitempty"`
	CallbackService          bool               `protobuf:"varint,15,opt,name=CallbackService" json:"CallbackService,omitempty"`
	CallbackServiceName      string             `protobuf:"bytes,16,opt,name=CallbackServiceName" json:"CallbackServiceName,omitempty"`
	OnErrorAbort             bool               `protobuf:"varint,17,opt,name=OnErrorAbort" json:"OnErrorAbort,omitempty"`
}

func (m *Submissions) Reset()                    { *m = Submissions{} }
func (m *Submissions) String() string            { return proto.CompactTextString(m) }
func (*Submissions) ProtoMessage()               {}
func (*Submissions) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *Submissions) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Submissions) GetSubmitted() uint32 {
	if m != nil {
		return m.Submitted
	}
	return 0
}

func (m *Submissions) GetModuleID() uint64 {
	if m != nil {
		return m.ModuleID
	}
	return 0
}

func (m *Submissions) GetType() singingcat.ComType {
	if m != nil {
		return m.Type
	}
	return singingcat.ComType_UNDEFINED
}

func (m *Submissions) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *Submissions) GetTimeout() uint32 {
	if m != nil {
		return m.Timeout
	}
	return 0
}

func (m *Submissions) GetApplicationReference() uint64 {
	if m != nil {
		return m.ApplicationReference
	}
	return 0
}

func (m *Submissions) GetLastAttempt() uint32 {
	if m != nil {
		return m.LastAttempt
	}
	return 0
}

func (m *Submissions) GetAttempts() uint32 {
	if m != nil {
		return m.Attempts
	}
	return 0
}

func (m *Submissions) GetLastResult() uint32 {
	if m != nil {
		return m.LastResult
	}
	return 0
}

func (m *Submissions) GetSubmitRequest() string {
	if m != nil {
		return m.SubmitRequest
	}
	return ""
}

func (m *Submissions) GetLastAnswerReceived() uint32 {
	if m != nil {
		return m.LastAnswerReceived
	}
	return 0
}

func (m *Submissions) GetCompletionAnswerReceived() uint32 {
	if m != nil {
		return m.CompletionAnswerReceived
	}
	return 0
}

func (m *Submissions) GetContext() []byte {
	if m != nil {
		return m.Context
	}
	return nil
}

func (m *Submissions) GetCallbackService() bool {
	if m != nil {
		return m.CallbackService
	}
	return false
}

func (m *Submissions) GetCallbackServiceName() string {
	if m != nil {
		return m.CallbackServiceName
	}
	return ""
}

func (m *Submissions) GetOnErrorAbort() bool {
	if m != nil {
		return m.OnErrorAbort
	}
	return false
}

type Result struct {
	ID         uint64       `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	Seq        uint32       `protobuf:"varint,2,opt,name=Seq" json:"Seq,omitempty"`
	Submission *Submissions `protobuf:"bytes,3,opt,name=Submission" json:"Submission,omitempty"`
	Command    string       `protobuf:"bytes,4,opt,name=Command" json:"Command,omitempty"`
	Received   uint32       `protobuf:"varint,5,opt,name=Received" json:"Received,omitempty"`
}

func (m *Result) Reset()                    { *m = Result{} }
func (m *Result) String() string            { return proto.CompactTextString(m) }
func (*Result) ProtoMessage()               {}
func (*Result) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Result) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Result) GetSeq() uint32 {
	if m != nil {
		return m.Seq
	}
	return 0
}

func (m *Result) GetSubmission() *Submissions {
	if m != nil {
		return m.Submission
	}
	return nil
}

func (m *Result) GetCommand() string {
	if m != nil {
		return m.Command
	}
	return ""
}

func (m *Result) GetReceived() uint32 {
	if m != nil {
		return m.Received
	}
	return 0
}

//
// submit a command to be sent to a module.
// If callbackservice == true, the sending service must implement rpc SCApplyCallback(scapply.CallbackResult) returns (common.Void)
type SubmitRequest struct {
	//
	// Any subsequent submissions with the same key will overwrite existing ones.
	// It is the calling application's responsibility to make sure the keys are 'sensible'.
	// the key is "world-scoped", that means submissions with a key that exists already will
	// override prior requests for other modules or command types as well
	Key                  string             `protobuf:"bytes,1,opt,name=Key" json:"Key,omitempty"`
	ModuleID             uint64             `protobuf:"varint,2,opt,name=ModuleID" json:"ModuleID,omitempty"`
	Type                 singingcat.ComType `protobuf:"varint,3,opt,name=Type,enum=singingcat.ComType" json:"Type,omitempty"`
	Args                 [][]byte           `protobuf:"bytes,4,rep,name=Args,proto3" json:"Args,omitempty"`
	Timeout              uint32             `protobuf:"varint,5,opt,name=Timeout" json:"Timeout,omitempty"`
	ApplicationReference uint64             `protobuf:"varint,6,opt,name=ApplicationReference" json:"ApplicationReference,omitempty"`
	CallbackService      bool               `protobuf:"varint,7,opt,name=CallbackService" json:"CallbackService,omitempty"`
	OnErrorAbort         bool               `protobuf:"varint,8,opt,name=OnErrorAbort" json:"OnErrorAbort,omitempty"`
}

func (m *SubmitRequest) Reset()                    { *m = SubmitRequest{} }
func (m *SubmitRequest) String() string            { return proto.CompactTextString(m) }
func (*SubmitRequest) ProtoMessage()               {}
func (*SubmitRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *SubmitRequest) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *SubmitRequest) GetModuleID() uint64 {
	if m != nil {
		return m.ModuleID
	}
	return 0
}

func (m *SubmitRequest) GetType() singingcat.ComType {
	if m != nil {
		return m.Type
	}
	return singingcat.ComType_UNDEFINED
}

func (m *SubmitRequest) GetArgs() [][]byte {
	if m != nil {
		return m.Args
	}
	return nil
}

func (m *SubmitRequest) GetTimeout() uint32 {
	if m != nil {
		return m.Timeout
	}
	return 0
}

func (m *SubmitRequest) GetApplicationReference() uint64 {
	if m != nil {
		return m.ApplicationReference
	}
	return 0
}

func (m *SubmitRequest) GetCallbackService() bool {
	if m != nil {
		return m.CallbackService
	}
	return false
}

func (m *SubmitRequest) GetOnErrorAbort() bool {
	if m != nil {
		return m.OnErrorAbort
	}
	return false
}

type SubmitBatchMsg struct {
	ModuleID uint64             `protobuf:"varint,1,opt,name=ModuleID" json:"ModuleID,omitempty"`
	Type     singingcat.ComType `protobuf:"varint,2,opt,name=Type,enum=singingcat.ComType" json:"Type,omitempty"`
	Args     [][]byte           `protobuf:"bytes,3,rep,name=Args,proto3" json:"Args,omitempty"`
}

func (m *SubmitBatchMsg) Reset()                    { *m = SubmitBatchMsg{} }
func (m *SubmitBatchMsg) String() string            { return proto.CompactTextString(m) }
func (*SubmitBatchMsg) ProtoMessage()               {}
func (*SubmitBatchMsg) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *SubmitBatchMsg) GetModuleID() uint64 {
	if m != nil {
		return m.ModuleID
	}
	return 0
}

func (m *SubmitBatchMsg) GetType() singingcat.ComType {
	if m != nil {
		return m.Type
	}
	return singingcat.ComType_UNDEFINED
}

func (m *SubmitBatchMsg) GetArgs() [][]byte {
	if m != nil {
		return m.Args
	}
	return nil
}

type SubmitBatchRequest struct {
	//
	// Any subsequent submissions with the same key will overwrite existing ones.
	// It is the calling application's responsibility to make sure the keys are 'sensible'.
	// the key is "world-scoped", that means submissions with a key that exists already will
	// override prior requests for other modules or command types as well
	Key                  string            `protobuf:"bytes,1,opt,name=Key" json:"Key,omitempty"`
	Commands             []*SubmitBatchMsg `protobuf:"bytes,2,rep,name=Commands" json:"Commands,omitempty"`
	Timeout              uint32            `protobuf:"varint,3,opt,name=Timeout" json:"Timeout,omitempty"`
	ApplicationReference uint64            `protobuf:"varint,4,opt,name=ApplicationReference" json:"ApplicationReference,omitempty"`
}

func (m *SubmitBatchRequest) Reset()                    { *m = SubmitBatchRequest{} }
func (m *SubmitBatchRequest) String() string            { return proto.CompactTextString(m) }
func (*SubmitBatchRequest) ProtoMessage()               {}
func (*SubmitBatchRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *SubmitBatchRequest) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *SubmitBatchRequest) GetCommands() []*SubmitBatchMsg {
	if m != nil {
		return m.Commands
	}
	return nil
}

func (m *SubmitBatchRequest) GetTimeout() uint32 {
	if m != nil {
		return m.Timeout
	}
	return 0
}

func (m *SubmitBatchRequest) GetApplicationReference() uint64 {
	if m != nil {
		return m.ApplicationReference
	}
	return 0
}

// one entry each time we submit a command
type SubmitAttempt struct {
	ID         uint64       `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	Submission *Submissions `protobuf:"bytes,2,opt,name=Submission" json:"Submission,omitempty"`
	Occured    uint32       `protobuf:"varint,3,opt,name=Occured" json:"Occured,omitempty"`
	Seq        uint32       `protobuf:"varint,4,opt,name=Seq" json:"Seq,omitempty"`
}

func (m *SubmitAttempt) Reset()                    { *m = SubmitAttempt{} }
func (m *SubmitAttempt) String() string            { return proto.CompactTextString(m) }
func (*SubmitAttempt) ProtoMessage()               {}
func (*SubmitAttempt) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *SubmitAttempt) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *SubmitAttempt) GetSubmission() *Submissions {
	if m != nil {
		return m.Submission
	}
	return nil
}

func (m *SubmitAttempt) GetOccured() uint32 {
	if m != nil {
		return m.Occured
	}
	return 0
}

func (m *SubmitAttempt) GetSeq() uint32 {
	if m != nil {
		return m.Seq
	}
	return 0
}

type WaitRequest struct {
	Key string `protobuf:"bytes,1,opt,name=Key" json:"Key,omitempty"`
}

func (m *WaitRequest) Reset()                    { *m = WaitRequest{} }
func (m *WaitRequest) String() string            { return proto.CompactTextString(m) }
func (*WaitRequest) ProtoMessage()               {}
func (*WaitRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *WaitRequest) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

type WaitResult struct {
	Completed  bool         `protobuf:"varint,1,opt,name=Completed" json:"Completed,omitempty"`
	Submission *Submissions `protobuf:"bytes,2,opt,name=Submission" json:"Submission,omitempty"`
}

func (m *WaitResult) Reset()                    { *m = WaitResult{} }
func (m *WaitResult) String() string            { return proto.CompactTextString(m) }
func (*WaitResult) ProtoMessage()               {}
func (*WaitResult) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *WaitResult) GetCompleted() bool {
	if m != nil {
		return m.Completed
	}
	return false
}

func (m *WaitResult) GetSubmission() *Submissions {
	if m != nil {
		return m.Submission
	}
	return nil
}

// posted to the callback service
type CallbackItem struct {
	Submission *Submissions          `protobuf:"bytes,1,opt,name=Submission" json:"Submission,omitempty"`
	Commands   []*singingcat.Command `protobuf:"bytes,2,rep,name=Commands" json:"Commands,omitempty"`
}

func (m *CallbackItem) Reset()                    { *m = CallbackItem{} }
func (m *CallbackItem) String() string            { return proto.CompactTextString(m) }
func (*CallbackItem) ProtoMessage()               {}
func (*CallbackItem) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *CallbackItem) GetSubmission() *Submissions {
	if m != nil {
		return m.Submission
	}
	return nil
}

func (m *CallbackItem) GetCommands() []*singingcat.Command {
	if m != nil {
		return m.Commands
	}
	return nil
}

// posted to the callback service
type CallbackResult struct {
	Success bool            `protobuf:"varint,1,opt,name=Success" json:"Success,omitempty"`
	Items   []*CallbackItem `protobuf:"bytes,2,rep,name=Items" json:"Items,omitempty"`
}

func (m *CallbackResult) Reset()                    { *m = CallbackResult{} }
func (m *CallbackResult) String() string            { return proto.CompactTextString(m) }
func (*CallbackResult) ProtoMessage()               {}
func (*CallbackResult) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *CallbackResult) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

func (m *CallbackResult) GetItems() []*CallbackItem {
	if m != nil {
		return m.Items
	}
	return nil
}

// database entry to queue callbacks and make sure only ever a single one is sent
type CallbackQueueEntry struct {
	ID         uint64       `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	Submission *Submissions `protobuf:"bytes,2,opt,name=Submission" json:"Submission,omitempty"`
	Seq        uint32       `protobuf:"varint,3,opt,name=Seq" json:"Seq,omitempty"`
	Completed  uint32       `protobuf:"varint,4,opt,name=Completed" json:"Completed,omitempty"`
	Created    uint32       `protobuf:"varint,5,opt,name=Created" json:"Created,omitempty"`
	LastCalled uint32       `protobuf:"varint,6,opt,name=LastCalled" json:"LastCalled,omitempty"`
}

func (m *CallbackQueueEntry) Reset()                    { *m = CallbackQueueEntry{} }
func (m *CallbackQueueEntry) String() string            { return proto.CompactTextString(m) }
func (*CallbackQueueEntry) ProtoMessage()               {}
func (*CallbackQueueEntry) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *CallbackQueueEntry) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *CallbackQueueEntry) GetSubmission() *Submissions {
	if m != nil {
		return m.Submission
	}
	return nil
}

func (m *CallbackQueueEntry) GetSeq() uint32 {
	if m != nil {
		return m.Seq
	}
	return 0
}

func (m *CallbackQueueEntry) GetCompleted() uint32 {
	if m != nil {
		return m.Completed
	}
	return 0
}

func (m *CallbackQueueEntry) GetCreated() uint32 {
	if m != nil {
		return m.Created
	}
	return 0
}

func (m *CallbackQueueEntry) GetLastCalled() uint32 {
	if m != nil {
		return m.LastCalled
	}
	return 0
}

func init() {
	proto.RegisterType((*Submissions)(nil), "scapply.Submissions")
	proto.RegisterType((*Result)(nil), "scapply.Result")
	proto.RegisterType((*SubmitRequest)(nil), "scapply.SubmitRequest")
	proto.RegisterType((*SubmitBatchMsg)(nil), "scapply.SubmitBatchMsg")
	proto.RegisterType((*SubmitBatchRequest)(nil), "scapply.SubmitBatchRequest")
	proto.RegisterType((*SubmitAttempt)(nil), "scapply.SubmitAttempt")
	proto.RegisterType((*WaitRequest)(nil), "scapply.WaitRequest")
	proto.RegisterType((*WaitResult)(nil), "scapply.WaitResult")
	proto.RegisterType((*CallbackItem)(nil), "scapply.CallbackItem")
	proto.RegisterType((*CallbackResult)(nil), "scapply.CallbackResult")
	proto.RegisterType((*CallbackQueueEntry)(nil), "scapply.CallbackQueueEntry")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Apply service

type ApplyClient interface {
	// Submit a new command
	Submit(ctx context.Context, in *SubmitRequest, opts ...grpc.CallOption) (*common.Void, error)
	// Submit a new batch of commands, which will be executed one after the other, in order
	SubmitBatch(ctx context.Context, in *SubmitBatchRequest, opts ...grpc.CallOption) (*common.Void, error)
	// called by scserver on every new command...
	CommandReceived(ctx context.Context, in *scmodcomms.Response, opts ...grpc.CallOption) (*common.Void, error)
	// wait for completion of a command. in case of DeadlineExceeded - retry
	WaitFor(ctx context.Context, in *WaitRequest, opts ...grpc.CallOption) (*WaitResult, error)
}

type applyClient struct {
	cc *grpc.ClientConn
}

func NewApplyClient(cc *grpc.ClientConn) ApplyClient {
	return &applyClient{cc}
}

func (c *applyClient) Submit(ctx context.Context, in *SubmitRequest, opts ...grpc.CallOption) (*common.Void, error) {
	out := new(common.Void)
	err := grpc.Invoke(ctx, "/scapply.Apply/Submit", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *applyClient) SubmitBatch(ctx context.Context, in *SubmitBatchRequest, opts ...grpc.CallOption) (*common.Void, error) {
	out := new(common.Void)
	err := grpc.Invoke(ctx, "/scapply.Apply/SubmitBatch", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *applyClient) CommandReceived(ctx context.Context, in *scmodcomms.Response, opts ...grpc.CallOption) (*common.Void, error) {
	out := new(common.Void)
	err := grpc.Invoke(ctx, "/scapply.Apply/CommandReceived", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *applyClient) WaitFor(ctx context.Context, in *WaitRequest, opts ...grpc.CallOption) (*WaitResult, error) {
	out := new(WaitResult)
	err := grpc.Invoke(ctx, "/scapply.Apply/WaitFor", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Apply service

type ApplyServer interface {
	// Submit a new command
	Submit(context.Context, *SubmitRequest) (*common.Void, error)
	// Submit a new batch of commands, which will be executed one after the other, in order
	SubmitBatch(context.Context, *SubmitBatchRequest) (*common.Void, error)
	// called by scserver on every new command...
	CommandReceived(context.Context, *scmodcomms.Response) (*common.Void, error)
	// wait for completion of a command. in case of DeadlineExceeded - retry
	WaitFor(context.Context, *WaitRequest) (*WaitResult, error)
}

func RegisterApplyServer(s *grpc.Server, srv ApplyServer) {
	s.RegisterService(&_Apply_serviceDesc, srv)
}

func _Apply_Submit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubmitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApplyServer).Submit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/scapply.Apply/Submit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApplyServer).Submit(ctx, req.(*SubmitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Apply_SubmitBatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubmitBatchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApplyServer).SubmitBatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/scapply.Apply/SubmitBatch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApplyServer).SubmitBatch(ctx, req.(*SubmitBatchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Apply_CommandReceived_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(scmodcomms.Response)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApplyServer).CommandReceived(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/scapply.Apply/CommandReceived",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApplyServer).CommandReceived(ctx, req.(*scmodcomms.Response))
	}
	return interceptor(ctx, in, info, handler)
}

func _Apply_WaitFor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WaitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApplyServer).WaitFor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/scapply.Apply/WaitFor",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApplyServer).WaitFor(ctx, req.(*WaitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Apply_serviceDesc = grpc.ServiceDesc{
	ServiceName: "scapply.Apply",
	HandlerType: (*ApplyServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Submit",
			Handler:    _Apply_Submit_Handler,
		},
		{
			MethodName: "SubmitBatch",
			Handler:    _Apply_SubmitBatch_Handler,
		},
		{
			MethodName: "CommandReceived",
			Handler:    _Apply_CommandReceived_Handler,
		},
		{
			MethodName: "WaitFor",
			Handler:    _Apply_WaitFor_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "golang.singingcat.net/apis/scapply/scapply.proto",
}

func init() { proto.RegisterFile("golang.singingcat.net/apis/scapply/scapply.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 941 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xac, 0x56, 0x5f, 0x8f, 0xdb, 0x44,
	0x10, 0x97, 0xf3, 0x3f, 0x93, 0x34, 0x57, 0xf6, 0x0a, 0xec, 0xa5, 0x07, 0x44, 0x56, 0x25, 0x22,
	0x21, 0xe5, 0xaa, 0xdc, 0x51, 0x21, 0xde, 0x2e, 0x77, 0x45, 0x3a, 0x41, 0xa9, 0xd8, 0xab, 0xa8,
	0xc4, 0x13, 0x3e, 0x7b, 0x08, 0x16, 0xb1, 0xd7, 0xf5, 0xae, 0x5b, 0xf2, 0x86, 0xee, 0x43, 0xf0,
	0xc0, 0x0b, 0x12, 0x6f, 0xf0, 0xcc, 0xe7, 0xe1, 0x03, 0xf0, 0x29, 0xd0, 0xae, 0xbd, 0xf6, 0xc6,
	0x4d, 0x4e, 0x79, 0xe0, 0xc9, 0x3b, 0x33, 0x3b, 0xb3, 0x33, 0xbf, 0xf9, 0xcd, 0x7a, 0xe1, 0xf1,
	0x92, 0xaf, 0xbc, 0x78, 0x39, 0x13, 0x61, 0xbc, 0x0c, 0xe3, 0xa5, 0xef, 0xc9, 0x59, 0x8c, 0xf2,
	0xc4, 0x4b, 0x42, 0x71, 0x22, 0x7c, 0x2f, 0x49, 0x56, 0x6b, 0xf3, 0x9d, 0x25, 0x29, 0x97, 0x9c,
	0x74, 0x0b, 0x71, 0x3c, 0x2b, 0x5c, 0x7d, 0x1e, 0xa7, 0x5e, 0xf0, 0x86, 0xf3, 0xa0, 0x72, 0xf5,
	0x79, 0x14, 0xf1, 0xb8, 0xf8, 0xe4, 0x8e, 0xe3, 0x27, 0x77, 0x1d, 0x55, 0xea, 0xac, 0xe5, 0x3e,
	0x7e, 0x7e, 0xc4, 0x03, 0x75, 0x8a, 0xbd, 0xcc, 0xfd, 0xdc, 0x5f, 0xda, 0x30, 0xb8, 0xce, 0x6e,
	0xa2, 0x50, 0x88, 0x90, 0xc7, 0x82, 0x8c, 0xa0, 0x71, 0x75, 0x49, 0x9d, 0x89, 0x33, 0x6d, 0xb1,
	0xc6, 0xd5, 0x25, 0x39, 0x86, 0xbe, 0x36, 0x4b, 0x89, 0x01, 0x6d, 0x4c, 0x9c, 0xe9, 0x3d, 0x56,
	0x29, 0xc8, 0x18, 0x7a, 0xcf, 0x78, 0x90, 0xad, 0xf0, 0xea, 0x92, 0x36, 0xb5, 0x4f, 0x29, 0x93,
	0x53, 0x68, 0xbd, 0x58, 0x27, 0x48, 0x5b, 0x13, 0x67, 0x3a, 0x9a, 0x1f, 0xda, 0x99, 0x5d, 0xf0,
	0x48, 0x99, 0x16, 0xf0, 0xdb, 0xed, 0x51, 0x27, 0x0b, 0x63, 0x79, 0x3a, 0x67, 0x7a, 0x33, 0x19,
	0x43, 0xf3, 0x4b, 0x5c, 0xd3, 0xf6, 0xc4, 0x99, 0xf6, 0x17, 0xbd, 0xbf, 0x6e, 0x8f, 0x5a, 0x32,
	0xcd, 0x90, 0x29, 0x25, 0xa1, 0xd0, 0x7d, 0x11, 0x46, 0xc8, 0x33, 0x49, 0x3b, 0x3a, 0x11, 0x23,
	0x92, 0x39, 0x3c, 0x38, 0x4f, 0x92, 0x55, 0xe8, 0x7b, 0x32, 0xe4, 0x31, 0xc3, 0x1f, 0x30, 0xc5,
	0xd8, 0x47, 0xda, 0xd5, 0x29, 0x6d, 0xb5, 0x91, 0x09, 0x0c, 0xbe, 0xf2, 0x84, 0x3c, 0x97, 0x12,
	0xa3, 0x44, 0xd2, 0x9e, 0x8e, 0x68, 0xab, 0x54, 0x71, 0xc5, 0x52, 0xd0, 0xbe, 0x36, 0x97, 0x32,
	0xf9, 0x10, 0x40, 0x6d, 0x65, 0x28, 0xb2, 0x95, 0xa4, 0xa0, 0xad, 0x96, 0x86, 0x3c, 0x82, 0x7b,
	0x39, 0x4a, 0x0c, 0x5f, 0x65, 0x28, 0x24, 0x1d, 0xa8, 0x8a, 0xd8, 0xa6, 0x92, 0xcc, 0x80, 0xe8,
	0x03, 0x63, 0xf1, 0x06, 0x53, 0x86, 0x3e, 0x86, 0xaf, 0x31, 0xa0, 0x43, 0x1d, 0x6d, 0x8b, 0x85,
	0x7c, 0x0e, 0xf4, 0x82, 0x47, 0xc9, 0x0a, 0x55, 0x29, 0x35, 0xaf, 0x7b, 0xda, 0x6b, 0xa7, 0x5d,
	0xa1, 0x77, 0xc1, 0x63, 0x89, 0x3f, 0x4b, 0x3a, 0x9a, 0x38, 0xd3, 0x21, 0x33, 0x22, 0x99, 0xc2,
	0xc1, 0x85, 0xb7, 0x5a, 0xdd, 0x78, 0xfe, 0x4f, 0xd7, 0x98, 0xbe, 0x0e, 0x7d, 0xa4, 0x07, 0x13,
	0x67, 0xda, 0x63, 0x75, 0x35, 0x79, 0x0c, 0x87, 0x35, 0xd5, 0xd7, 0x5e, 0x84, 0xf4, 0xbe, 0xae,
	0x6d, 0x9b, 0x89, 0xb8, 0x30, 0x7c, 0x1e, 0x3f, 0x4d, 0x53, 0x9e, 0x9e, 0xdf, 0xf0, 0x54, 0xd2,
	0x77, 0x74, 0xe0, 0x0d, 0x9d, 0xfb, 0xb7, 0x03, 0x9d, 0x02, 0xb6, 0x3a, 0xfb, 0xee, 0x43, 0xf3,
	0x1a, 0x5f, 0x15, 0xbc, 0x53, 0x4b, 0xc2, 0x00, 0x2a, 0xba, 0x6a, 0xce, 0x0d, 0xe6, 0x0f, 0x66,
	0x66, 0xf8, 0x2c, 0x26, 0x2f, 0x8e, 0x0d, 0xb9, 0x9e, 0x9c, 0xfd, 0x71, 0x7b, 0x34, 0x12, 0x95,
	0x69, 0x16, 0x06, 0xcc, 0x8a, 0x92, 0x43, 0x13, 0x45, 0x5e, 0x1c, 0x68, 0xb2, 0xf6, 0x99, 0x11,
	0x15, 0x05, 0x4a, 0x80, 0xdb, 0x39, 0x05, 0x8c, 0xec, 0xfe, 0xda, 0xa8, 0xf5, 0x58, 0x65, 0xab,
	0xc8, 0xeb, 0xe8, 0x18, 0x9a, 0xb2, 0xf6, 0x7c, 0x34, 0x6a, 0xf3, 0xf1, 0x71, 0x31, 0x1f, 0xcd,
	0x9d, 0xf3, 0x51, 0xcc, 0x04, 0x81, 0xd6, 0x79, 0xba, 0x14, 0xb4, 0x35, 0x69, 0x4e, 0x87, 0x4c,
	0xaf, 0xed, 0x59, 0x68, 0xef, 0x37, 0x0b, 0x9d, 0x3b, 0x66, 0x61, 0x0b, 0x03, 0xba, 0xdb, 0x19,
	0x50, 0xef, 0x67, 0x6f, 0x4b, 0x3f, 0x43, 0x18, 0xe5, 0xb8, 0x2c, 0x3c, 0xe9, 0xff, 0xf8, 0x4c,
	0x2c, 0x37, 0x60, 0x70, 0x76, 0xc0, 0xd0, 0xd8, 0x17, 0x86, 0x66, 0x05, 0x83, 0xfb, 0xa7, 0x03,
	0xc4, 0x3a, 0x6b, 0x77, 0x23, 0x4e, 0xa1, 0x57, 0xf4, 0x54, 0xd0, 0xc6, 0xa4, 0x39, 0x1d, 0xcc,
	0xdf, 0xdf, 0x24, 0x4d, 0x99, 0x2c, 0x2b, 0x37, 0xda, 0x20, 0x37, 0xf7, 0x03, 0xb9, 0xb5, 0x1b,
	0x64, 0xf7, 0x77, 0xc7, 0xf0, 0xc5, 0x5c, 0x30, 0x75, 0xb6, 0x6f, 0x72, 0xbb, 0xf1, 0x7f, 0x71,
	0xfb, 0xb9, 0xef, 0x67, 0x29, 0x06, 0xa6, 0x86, 0x42, 0x34, 0xb3, 0xd5, 0x2a, 0x67, 0xcb, 0xfd,
	0x08, 0x06, 0x2f, 0xbd, 0x3b, 0xe8, 0xec, 0x7e, 0x0f, 0x90, 0x6f, 0xd0, 0xc3, 0x7a, 0x0c, 0xfd,
	0xe2, 0xb6, 0xc1, 0x40, 0xef, 0xea, 0xb1, 0x4a, 0x41, 0xce, 0xf6, 0x2d, 0xc6, 0x4e, 0xd7, 0xcd,
	0x60, 0x68, 0x28, 0x77, 0x25, 0x31, 0xaa, 0x45, 0x71, 0xf6, 0x8b, 0x42, 0x4e, 0xde, 0xea, 0x76,
	0x9d, 0x57, 0xca, 0x56, 0x75, 0xda, 0x7d, 0x09, 0x23, 0x73, 0x6c, 0x51, 0x1c, 0x85, 0xee, 0x75,
	0xe6, 0xfb, 0x28, 0x44, 0x51, 0x9a, 0x11, 0xc9, 0x27, 0xd0, 0x56, 0xa9, 0x99, 0xc8, 0xef, 0x96,
	0xd9, 0xd8, 0x89, 0xb3, 0x7c, 0x8f, 0xfb, 0xaf, 0x03, 0xc4, 0xe8, 0xbf, 0xc9, 0x30, 0xc3, 0xa7,
	0xb1, 0x4c, 0xd7, 0x6f, 0x75, 0xfe, 0xbb, 0xbd, 0x3b, 0xff, 0xe8, 0xae, 0xce, 0x97, 0xff, 0x4b,
	0x1b, 0x8c, 0xa2, 0xcf, 0xcd, 0xea, 0x0e, 0xdd, 0x68, 0x5c, 0xde, 0x7f, 0xab, 0x71, 0xea, 0x36,
	0x4c, 0xd1, 0x93, 0xe5, 0x95, 0x67, 0x44, 0xf3, 0xd3, 0x53, 0xf5, 0x60, 0x50, 0xfc, 0x83, 0x2d,
	0xcd, 0xfc, 0x1f, 0x07, 0xda, 0x8a, 0xfa, 0x6b, 0x32, 0x83, 0x4e, 0x4e, 0x75, 0xf2, 0x5e, 0x6d,
	0xcc, 0x0a, 0x72, 0x8d, 0x87, 0xb3, 0xe2, 0xd9, 0xf3, 0x2d, 0x0f, 0x03, 0xf2, 0x59, 0xf1, 0x08,
	0xc9, 0xa7, 0x90, 0x3c, 0xdc, 0x36, 0x9b, 0xdb, 0x3d, 0x3f, 0x85, 0x03, 0xd3, 0x4e, 0xf3, 0xa7,
	0x53, 0xc0, 0x95, 0xaf, 0x1c, 0x86, 0x22, 0xe1, 0xb1, 0xc0, 0x9a, 0xdb, 0x19, 0x74, 0x15, 0x93,
	0xbf, 0xe0, 0x29, 0xa9, 0x70, 0xb6, 0xc8, 0x3f, 0x3e, 0xac, 0x69, 0x15, 0x29, 0x16, 0x1f, 0xc0,
	0xc3, 0x18, 0xa5, 0x4d, 0x25, 0xf5, 0xbe, 0x32, 0x3b, 0x6f, 0x3a, 0xfa, 0x49, 0x75, 0xfa, 0x5f,
	0x00, 0x00, 0x00, 0xff, 0xff, 0x2c, 0x1d, 0xeb, 0x09, 0x2f, 0x0a, 0x00, 0x00,
}
