// Code generated by protoc-gen-go.
// source: golang.singingcat.net/apis/sensors/sensors.proto
// DO NOT EDIT!

/*
Package sensors is a generated protocol buffer package.

It is generated from these files:
	golang.singingcat.net/apis/sensors/sensors.proto

It has these top-level messages:
	SensorRef
	SensorQuery
	SensorValue
	StoreRequest
	DBSensorValue
	SensorDef
	SensorList
	SensorInfo
	SensorConfig
	SensorValueList
*/
package sensors

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import singingcat "golang.singingcat.net/apis/singingcat"
import scmodcomms "golang.singingcat.net/apis/scmodcomms"
import scapply "golang.singingcat.net/apis/scapply"
import common "golang.conradwood.net/apis/common"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type SensorRef struct {
	ID uint64 `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
}

func (m *SensorRef) Reset()                    { *m = SensorRef{} }
func (m *SensorRef) String() string            { return proto.CompactTextString(m) }
func (*SensorRef) ProtoMessage()               {}
func (*SensorRef) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *SensorRef) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

type SensorQuery struct {
	Sensor *SensorRef `protobuf:"bytes,1,opt,name=Sensor" json:"Sensor,omitempty"`
	Start  uint32     `protobuf:"varint,2,opt,name=Start" json:"Start,omitempty"`
	End    uint32     `protobuf:"varint,3,opt,name=End" json:"End,omitempty"`
}

func (m *SensorQuery) Reset()                    { *m = SensorQuery{} }
func (m *SensorQuery) String() string            { return proto.CompactTextString(m) }
func (*SensorQuery) ProtoMessage()               {}
func (*SensorQuery) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *SensorQuery) GetSensor() *SensorRef {
	if m != nil {
		return m.Sensor
	}
	return nil
}

func (m *SensorQuery) GetStart() uint32 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *SensorQuery) GetEnd() uint32 {
	if m != nil {
		return m.End
	}
	return 0
}

type SensorValue struct {
	Timestamp uint32  `protobuf:"varint,1,opt,name=Timestamp" json:"Timestamp,omitempty"`
	Value     float64 `protobuf:"fixed64,2,opt,name=Value" json:"Value,omitempty"`
}

func (m *SensorValue) Reset()                    { *m = SensorValue{} }
func (m *SensorValue) String() string            { return proto.CompactTextString(m) }
func (*SensorValue) ProtoMessage()               {}
func (*SensorValue) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *SensorValue) GetTimestamp() uint32 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *SensorValue) GetValue() float64 {
	if m != nil {
		return m.Value
	}
	return 0
}

type StoreRequest struct {
	Sensor    *SensorRef `protobuf:"bytes,1,opt,name=Sensor" json:"Sensor,omitempty"`
	Timestamp uint32     `protobuf:"varint,2,opt,name=Timestamp" json:"Timestamp,omitempty"`
	Value     int64      `protobuf:"varint,3,opt,name=Value" json:"Value,omitempty"`
}

func (m *StoreRequest) Reset()                    { *m = StoreRequest{} }
func (m *StoreRequest) String() string            { return proto.CompactTextString(m) }
func (*StoreRequest) ProtoMessage()               {}
func (*StoreRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *StoreRequest) GetSensor() *SensorRef {
	if m != nil {
		return m.Sensor
	}
	return nil
}

func (m *StoreRequest) GetTimestamp() uint32 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *StoreRequest) GetValue() int64 {
	if m != nil {
		return m.Value
	}
	return 0
}

// normalized prober sensorvalue
type DBSensorValue struct {
	ID        uint64  `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	SensorID  uint64  `protobuf:"varint,2,opt,name=SensorID" json:"SensorID,omitempty"`
	Timestamp uint32  `protobuf:"varint,3,opt,name=Timestamp" json:"Timestamp,omitempty"`
	Value     float64 `protobuf:"fixed64,4,opt,name=Value" json:"Value,omitempty"`
}

func (m *DBSensorValue) Reset()                    { *m = DBSensorValue{} }
func (m *DBSensorValue) String() string            { return proto.CompactTextString(m) }
func (*DBSensorValue) ProtoMessage()               {}
func (*DBSensorValue) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *DBSensorValue) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *DBSensorValue) GetSensorID() uint64 {
	if m != nil {
		return m.SensorID
	}
	return 0
}

func (m *DBSensorValue) GetTimestamp() uint32 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *DBSensorValue) GetValue() float64 {
	if m != nil {
		return m.Value
	}
	return 0
}

type SensorDef struct {
	ID        uint64 `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	Index     uint32 `protobuf:"varint,2,opt,name=Index" json:"Index,omitempty"`
	ModuleID  uint64 `protobuf:"varint,3,opt,name=ModuleID" json:"ModuleID,omitempty"`
	Name      string `protobuf:"bytes,4,opt,name=Name" json:"Name,omitempty"`
	Type      string `protobuf:"bytes,5,opt,name=Type" json:"Type,omitempty"`
	Available bool   `protobuf:"varint,6,opt,name=Available" json:"Available,omitempty"`
	//  string FriendlyName=7;
	Flags    uint32 `protobuf:"varint,8,opt,name=Flags" json:"Flags,omitempty"`
	Detected bool   `protobuf:"varint,9,opt,name=Detected" json:"Detected,omitempty"`
}

func (m *SensorDef) Reset()                    { *m = SensorDef{} }
func (m *SensorDef) String() string            { return proto.CompactTextString(m) }
func (*SensorDef) ProtoMessage()               {}
func (*SensorDef) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *SensorDef) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *SensorDef) GetIndex() uint32 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *SensorDef) GetModuleID() uint64 {
	if m != nil {
		return m.ModuleID
	}
	return 0
}

func (m *SensorDef) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *SensorDef) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *SensorDef) GetAvailable() bool {
	if m != nil {
		return m.Available
	}
	return false
}

func (m *SensorDef) GetFlags() uint32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *SensorDef) GetDetected() bool {
	if m != nil {
		return m.Detected
	}
	return false
}

type SensorList struct {
	Sensors []*SensorInfo `protobuf:"bytes,1,rep,name=Sensors" json:"Sensors,omitempty"`
}

func (m *SensorList) Reset()                    { *m = SensorList{} }
func (m *SensorList) String() string            { return proto.CompactTextString(m) }
func (*SensorList) ProtoMessage()               {}
func (*SensorList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *SensorList) GetSensors() []*SensorInfo {
	if m != nil {
		return m.Sensors
	}
	return nil
}

type SensorInfo struct {
	Config   *SensorConfig `protobuf:"bytes,1,opt,name=Config" json:"Config,omitempty"`
	Value    *SensorValue  `protobuf:"bytes,2,opt,name=Value" json:"Value,omitempty"`
	UnitName string        `protobuf:"bytes,3,opt,name=UnitName" json:"UnitName,omitempty"`
}

func (m *SensorInfo) Reset()                    { *m = SensorInfo{} }
func (m *SensorInfo) String() string            { return proto.CompactTextString(m) }
func (*SensorInfo) ProtoMessage()               {}
func (*SensorInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *SensorInfo) GetConfig() *SensorConfig {
	if m != nil {
		return m.Config
	}
	return nil
}

func (m *SensorInfo) GetValue() *SensorValue {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *SensorInfo) GetUnitName() string {
	if m != nil {
		return m.UnitName
	}
	return ""
}

//
// The configuration of a given sensor. The upper limit on polling interval and reporting interval is determined by 'bandwidth'.
// Each 'reportinginterval' will report multiple values, depending on how often it was polled since last report.
type SensorConfig struct {
	ID                uint64     `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	SensorDef         *SensorDef `protobuf:"bytes,2,opt,name=SensorDef" json:"SensorDef,omitempty"`
	Enabled           bool       `protobuf:"varint,3,opt,name=Enabled" json:"Enabled,omitempty"`
	ReportingInterval uint32     `protobuf:"varint,4,opt,name=ReportingInterval" json:"ReportingInterval,omitempty"`
	PollingInterval   uint32     `protobuf:"varint,5,opt,name=PollingInterval" json:"PollingInterval,omitempty"`
	FriendlyName      string     `protobuf:"bytes,6,opt,name=FriendlyName" json:"FriendlyName,omitempty"`
}

func (m *SensorConfig) Reset()                    { *m = SensorConfig{} }
func (m *SensorConfig) String() string            { return proto.CompactTextString(m) }
func (*SensorConfig) ProtoMessage()               {}
func (*SensorConfig) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *SensorConfig) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *SensorConfig) GetSensorDef() *SensorDef {
	if m != nil {
		return m.SensorDef
	}
	return nil
}

func (m *SensorConfig) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

func (m *SensorConfig) GetReportingInterval() uint32 {
	if m != nil {
		return m.ReportingInterval
	}
	return 0
}

func (m *SensorConfig) GetPollingInterval() uint32 {
	if m != nil {
		return m.PollingInterval
	}
	return 0
}

func (m *SensorConfig) GetFriendlyName() string {
	if m != nil {
		return m.FriendlyName
	}
	return ""
}

type SensorValueList struct {
	Values []*SensorValue `protobuf:"bytes,1,rep,name=Values" json:"Values,omitempty"`
}

func (m *SensorValueList) Reset()                    { *m = SensorValueList{} }
func (m *SensorValueList) String() string            { return proto.CompactTextString(m) }
func (*SensorValueList) ProtoMessage()               {}
func (*SensorValueList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *SensorValueList) GetValues() []*SensorValue {
	if m != nil {
		return m.Values
	}
	return nil
}

func init() {
	proto.RegisterType((*SensorRef)(nil), "sensors.SensorRef")
	proto.RegisterType((*SensorQuery)(nil), "sensors.SensorQuery")
	proto.RegisterType((*SensorValue)(nil), "sensors.SensorValue")
	proto.RegisterType((*StoreRequest)(nil), "sensors.StoreRequest")
	proto.RegisterType((*DBSensorValue)(nil), "sensors.DBSensorValue")
	proto.RegisterType((*SensorDef)(nil), "sensors.SensorDef")
	proto.RegisterType((*SensorList)(nil), "sensors.SensorList")
	proto.RegisterType((*SensorInfo)(nil), "sensors.SensorInfo")
	proto.RegisterType((*SensorConfig)(nil), "sensors.SensorConfig")
	proto.RegisterType((*SensorValueList)(nil), "sensors.SensorValueList")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for SensorServer service

type SensorServerClient interface {
	DevicePoweredUp(ctx context.Context, in *singingcat.ModuleRef, opts ...grpc.CallOption) (*common.Void, error)
	CommandReceived(ctx context.Context, in *scmodcomms.Response, opts ...grpc.CallOption) (*common.Void, error)
	GetSensorValues(ctx context.Context, in *SensorQuery, opts ...grpc.CallOption) (*SensorValueList, error)
	// returns sensorvalue with timestamp ==0 if there isn't one (yet)
	GetMostRecentValue(ctx context.Context, in *SensorRef, opts ...grpc.CallOption) (*SensorValue, error)
	StoreValue(ctx context.Context, in *StoreRequest, opts ...grpc.CallOption) (*SensorValue, error)
	// callback from scapply when my commands are completed
	SCApplyCallback(ctx context.Context, in *scapply.CallbackResult, opts ...grpc.CallOption) (*common.Void, error)
	// match sensor IDs with those from scweb. This only needs to be run during migration and should be deleted once migration is complete
	FixIDs(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*common.Void, error)
	// get the current list of sensors and their configuration
	GetSensorsForModule(ctx context.Context, in *singingcat.ModuleRef, opts ...grpc.CallOption) (*SensorList, error)
	// set a sensor configuration
	SetConfig(ctx context.Context, in *SensorConfig, opts ...grpc.CallOption) (*common.Void, error)
	// get sensor config by sensordef id
	GetSensorByID(ctx context.Context, in *SensorRef, opts ...grpc.CallOption) (*SensorInfo, error)
}

type sensorServerClient struct {
	cc *grpc.ClientConn
}

func NewSensorServerClient(cc *grpc.ClientConn) SensorServerClient {
	return &sensorServerClient{cc}
}

func (c *sensorServerClient) DevicePoweredUp(ctx context.Context, in *singingcat.ModuleRef, opts ...grpc.CallOption) (*common.Void, error) {
	out := new(common.Void)
	err := grpc.Invoke(ctx, "/sensors.SensorServer/DevicePoweredUp", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sensorServerClient) CommandReceived(ctx context.Context, in *scmodcomms.Response, opts ...grpc.CallOption) (*common.Void, error) {
	out := new(common.Void)
	err := grpc.Invoke(ctx, "/sensors.SensorServer/CommandReceived", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sensorServerClient) GetSensorValues(ctx context.Context, in *SensorQuery, opts ...grpc.CallOption) (*SensorValueList, error) {
	out := new(SensorValueList)
	err := grpc.Invoke(ctx, "/sensors.SensorServer/GetSensorValues", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sensorServerClient) GetMostRecentValue(ctx context.Context, in *SensorRef, opts ...grpc.CallOption) (*SensorValue, error) {
	out := new(SensorValue)
	err := grpc.Invoke(ctx, "/sensors.SensorServer/GetMostRecentValue", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sensorServerClient) StoreValue(ctx context.Context, in *StoreRequest, opts ...grpc.CallOption) (*SensorValue, error) {
	out := new(SensorValue)
	err := grpc.Invoke(ctx, "/sensors.SensorServer/StoreValue", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sensorServerClient) SCApplyCallback(ctx context.Context, in *scapply.CallbackResult, opts ...grpc.CallOption) (*common.Void, error) {
	out := new(common.Void)
	err := grpc.Invoke(ctx, "/sensors.SensorServer/SCApplyCallback", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sensorServerClient) FixIDs(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*common.Void, error) {
	out := new(common.Void)
	err := grpc.Invoke(ctx, "/sensors.SensorServer/FixIDs", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sensorServerClient) GetSensorsForModule(ctx context.Context, in *singingcat.ModuleRef, opts ...grpc.CallOption) (*SensorList, error) {
	out := new(SensorList)
	err := grpc.Invoke(ctx, "/sensors.SensorServer/GetSensorsForModule", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sensorServerClient) SetConfig(ctx context.Context, in *SensorConfig, opts ...grpc.CallOption) (*common.Void, error) {
	out := new(common.Void)
	err := grpc.Invoke(ctx, "/sensors.SensorServer/SetConfig", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sensorServerClient) GetSensorByID(ctx context.Context, in *SensorRef, opts ...grpc.CallOption) (*SensorInfo, error) {
	out := new(SensorInfo)
	err := grpc.Invoke(ctx, "/sensors.SensorServer/GetSensorByID", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for SensorServer service

type SensorServerServer interface {
	DevicePoweredUp(context.Context, *singingcat.ModuleRef) (*common.Void, error)
	CommandReceived(context.Context, *scmodcomms.Response) (*common.Void, error)
	GetSensorValues(context.Context, *SensorQuery) (*SensorValueList, error)
	// returns sensorvalue with timestamp ==0 if there isn't one (yet)
	GetMostRecentValue(context.Context, *SensorRef) (*SensorValue, error)
	StoreValue(context.Context, *StoreRequest) (*SensorValue, error)
	// callback from scapply when my commands are completed
	SCApplyCallback(context.Context, *scapply.CallbackResult) (*common.Void, error)
	// match sensor IDs with those from scweb. This only needs to be run during migration and should be deleted once migration is complete
	FixIDs(context.Context, *common.Void) (*common.Void, error)
	// get the current list of sensors and their configuration
	GetSensorsForModule(context.Context, *singingcat.ModuleRef) (*SensorList, error)
	// set a sensor configuration
	SetConfig(context.Context, *SensorConfig) (*common.Void, error)
	// get sensor config by sensordef id
	GetSensorByID(context.Context, *SensorRef) (*SensorInfo, error)
}

func RegisterSensorServerServer(s *grpc.Server, srv SensorServerServer) {
	s.RegisterService(&_SensorServer_serviceDesc, srv)
}

func _SensorServer_DevicePoweredUp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(singingcat.ModuleRef)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SensorServerServer).DevicePoweredUp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sensors.SensorServer/DevicePoweredUp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SensorServerServer).DevicePoweredUp(ctx, req.(*singingcat.ModuleRef))
	}
	return interceptor(ctx, in, info, handler)
}

func _SensorServer_CommandReceived_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(scmodcomms.Response)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SensorServerServer).CommandReceived(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sensors.SensorServer/CommandReceived",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SensorServerServer).CommandReceived(ctx, req.(*scmodcomms.Response))
	}
	return interceptor(ctx, in, info, handler)
}

func _SensorServer_GetSensorValues_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SensorQuery)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SensorServerServer).GetSensorValues(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sensors.SensorServer/GetSensorValues",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SensorServerServer).GetSensorValues(ctx, req.(*SensorQuery))
	}
	return interceptor(ctx, in, info, handler)
}

func _SensorServer_GetMostRecentValue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SensorRef)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SensorServerServer).GetMostRecentValue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sensors.SensorServer/GetMostRecentValue",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SensorServerServer).GetMostRecentValue(ctx, req.(*SensorRef))
	}
	return interceptor(ctx, in, info, handler)
}

func _SensorServer_StoreValue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StoreRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SensorServerServer).StoreValue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sensors.SensorServer/StoreValue",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SensorServerServer).StoreValue(ctx, req.(*StoreRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SensorServer_SCApplyCallback_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(scapply.CallbackResult)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SensorServerServer).SCApplyCallback(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sensors.SensorServer/SCApplyCallback",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SensorServerServer).SCApplyCallback(ctx, req.(*scapply.CallbackResult))
	}
	return interceptor(ctx, in, info, handler)
}

func _SensorServer_FixIDs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SensorServerServer).FixIDs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sensors.SensorServer/FixIDs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SensorServerServer).FixIDs(ctx, req.(*common.Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _SensorServer_GetSensorsForModule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(singingcat.ModuleRef)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SensorServerServer).GetSensorsForModule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sensors.SensorServer/GetSensorsForModule",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SensorServerServer).GetSensorsForModule(ctx, req.(*singingcat.ModuleRef))
	}
	return interceptor(ctx, in, info, handler)
}

func _SensorServer_SetConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SensorConfig)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SensorServerServer).SetConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sensors.SensorServer/SetConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SensorServerServer).SetConfig(ctx, req.(*SensorConfig))
	}
	return interceptor(ctx, in, info, handler)
}

func _SensorServer_GetSensorByID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SensorRef)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SensorServerServer).GetSensorByID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sensors.SensorServer/GetSensorByID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SensorServerServer).GetSensorByID(ctx, req.(*SensorRef))
	}
	return interceptor(ctx, in, info, handler)
}

var _SensorServer_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sensors.SensorServer",
	HandlerType: (*SensorServerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "DevicePoweredUp",
			Handler:    _SensorServer_DevicePoweredUp_Handler,
		},
		{
			MethodName: "CommandReceived",
			Handler:    _SensorServer_CommandReceived_Handler,
		},
		{
			MethodName: "GetSensorValues",
			Handler:    _SensorServer_GetSensorValues_Handler,
		},
		{
			MethodName: "GetMostRecentValue",
			Handler:    _SensorServer_GetMostRecentValue_Handler,
		},
		{
			MethodName: "StoreValue",
			Handler:    _SensorServer_StoreValue_Handler,
		},
		{
			MethodName: "SCApplyCallback",
			Handler:    _SensorServer_SCApplyCallback_Handler,
		},
		{
			MethodName: "FixIDs",
			Handler:    _SensorServer_FixIDs_Handler,
		},
		{
			MethodName: "GetSensorsForModule",
			Handler:    _SensorServer_GetSensorsForModule_Handler,
		},
		{
			MethodName: "SetConfig",
			Handler:    _SensorServer_SetConfig_Handler,
		},
		{
			MethodName: "GetSensorByID",
			Handler:    _SensorServer_GetSensorByID_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "golang.singingcat.net/apis/sensors/sensors.proto",
}

func init() { proto.RegisterFile("golang.singingcat.net/apis/sensors/sensors.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 829 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x94, 0x55, 0x5f, 0x6f, 0xdb, 0x36,
	0x10, 0x87, 0xff, 0xc4, 0x49, 0x2e, 0xf6, 0xbc, 0xb1, 0x29, 0xa6, 0x7a, 0x7b, 0x08, 0x84, 0x3e,
	0x18, 0x45, 0xab, 0x16, 0xd9, 0x16, 0x74, 0x18, 0xb0, 0x21, 0x89, 0x9a, 0xc2, 0x40, 0x3b, 0x74,
	0x74, 0xdb, 0x77, 0x46, 0x3a, 0x1b, 0xc4, 0x24, 0x52, 0x13, 0x69, 0xb7, 0x7e, 0xcd, 0xbe, 0xc5,
	0x1e, 0xf7, 0x5d, 0xf6, 0xb2, 0x4f, 0x35, 0x90, 0x94, 0x14, 0x46, 0x71, 0x02, 0xec, 0x49, 0xfc,
	0x1d, 0xef, 0xf8, 0xbb, 0xfb, 0x1d, 0x79, 0x82, 0x17, 0x4b, 0x99, 0x31, 0xb1, 0x8c, 0x14, 0x17,
	0x4b, 0x2e, 0x96, 0x09, 0xd3, 0x91, 0x40, 0xfd, 0x9c, 0x15, 0x5c, 0x3d, 0x57, 0x28, 0x94, 0x2c,
	0x9b, 0x6f, 0x54, 0x94, 0x52, 0x4b, 0xb2, 0x5b, 0xc1, 0xc9, 0xc9, 0x7d, 0xa1, 0x8d, 0xcd, 0x5b,
	0xba, 0x03, 0xee, 0x8f, 0x4b, 0x72, 0x99, 0x26, 0x32, 0xcf, 0xfd, 0x65, 0x15, 0x77, 0x6f, 0xaa,
	0x09, 0x2b, 0x8a, 0x6c, 0x53, 0x7f, 0xab, 0x88, 0xa8, 0x8a, 0x48, 0xa4, 0x28, 0x59, 0xfa, 0x49,
	0xca, 0xf4, 0x3a, 0xc2, 0x9c, 0x2c, 0x45, 0xf5, 0x71, 0xfe, 0xe1, 0x37, 0xb0, 0x3f, 0xb7, 0xc5,
	0x51, 0x5c, 0x90, 0x2f, 0xa0, 0x3b, 0x8b, 0x83, 0xce, 0x51, 0x67, 0xda, 0xa7, 0xdd, 0x59, 0x1c,
	0x32, 0x38, 0x70, 0x9b, 0xbf, 0xad, 0xb0, 0xdc, 0x90, 0x27, 0x30, 0x70, 0xd0, 0xba, 0x1c, 0x1c,
	0x93, 0xa8, 0x96, 0xa9, 0x39, 0x82, 0x56, 0x1e, 0xe4, 0x10, 0x76, 0xe6, 0x9a, 0x95, 0x3a, 0xe8,
	0x1e, 0x75, 0xa6, 0x23, 0xea, 0x00, 0xf9, 0x12, 0x7a, 0xaf, 0x44, 0x1a, 0xf4, 0xac, 0xcd, 0x2c,
	0xc3, 0xd3, 0x9a, 0xe2, 0x23, 0xcb, 0x56, 0x48, 0xbe, 0x85, 0xfd, 0xf7, 0x3c, 0x47, 0xa5, 0x59,
	0x5e, 0x58, 0x96, 0x11, 0xbd, 0x36, 0x98, 0x43, 0xad, 0x9b, 0x3d, 0xb4, 0x43, 0x1d, 0x08, 0x05,
	0x0c, 0xe7, 0x5a, 0x96, 0x48, 0xf1, 0x8f, 0x15, 0x2a, 0xfd, 0xbf, 0xd2, 0xbc, 0xc1, 0xd7, 0xbd,
	0x93, 0xcf, 0x24, 0xdc, 0xab, 0xf9, 0x24, 0x8c, 0xe2, 0x33, 0x3f, 0xe9, 0x96, 0x6c, 0x64, 0x02,
	0x7b, 0x6e, 0x7b, 0x16, 0xdb, 0x33, 0xfb, 0xb4, 0xc1, 0x37, 0x09, 0x7b, 0x77, 0x12, 0xf6, 0xfd,
	0x02, 0xff, 0xe9, 0xd4, 0x4d, 0x8a, 0x6f, 0x37, 0xc9, 0xc4, 0xcc, 0x44, 0x8a, 0x9f, 0x6b, 0xa5,
	0x2d, 0x30, 0x39, 0xbc, 0x95, 0xe9, 0x2a, 0xc3, 0x59, 0x6c, 0x69, 0xfa, 0xb4, 0xc1, 0x84, 0x40,
	0xff, 0x57, 0x96, 0x3b, 0x92, 0x7d, 0x6a, 0xd7, 0xc6, 0xf6, 0x7e, 0x53, 0x60, 0xb0, 0xe3, 0x6c,
	0x66, 0x6d, 0x72, 0x3d, 0x5d, 0x33, 0x9e, 0xb1, 0xcb, 0x0c, 0x83, 0xc1, 0x51, 0x67, 0xba, 0x47,
	0xaf, 0x0d, 0x86, 0xf7, 0x22, 0x63, 0x4b, 0x15, 0xec, 0x39, 0x5e, 0x0b, 0x0c, 0x6f, 0x8c, 0x1a,
	0x13, 0x8d, 0x69, 0xb0, 0x6f, 0x43, 0x1a, 0x1c, 0xfe, 0x04, 0xe0, 0xca, 0x78, 0xc3, 0x95, 0x26,
	0xcf, 0x60, 0xd7, 0x21, 0x15, 0x74, 0x8e, 0x7a, 0xd3, 0x83, 0xe3, 0x07, 0xad, 0x3e, 0xcd, 0xc4,
	0x42, 0xd2, 0xda, 0x27, 0xfc, 0xb3, 0x53, 0x47, 0x1b, 0x3b, 0x79, 0x06, 0x83, 0x73, 0x29, 0x16,
	0x7c, 0x59, 0x35, 0xf9, 0x61, 0x2b, 0xd8, 0x6d, 0xd2, 0xca, 0x89, 0x3c, 0xf1, 0x6f, 0xce, 0xc1,
	0xf1, 0x61, 0xcb, 0xdb, 0xee, 0x55, 0x72, 0x9b, 0x12, 0x3e, 0x08, 0xae, 0xad, 0x44, 0x3d, 0x2b,
	0x47, 0x83, 0xc3, 0xab, 0x2e, 0x0c, 0x7d, 0x82, 0x5b, 0xdd, 0x78, 0xe3, 0xb5, 0xaa, 0x22, 0x6b,
	0xdf, 0xbf, 0x18, 0x17, 0x67, 0x93, 0xbf, 0xae, 0x1e, 0x0d, 0x56, 0x5c, 0xe8, 0x93, 0xef, 0xff,
	0xbe, 0x7a, 0x34, 0x74, 0x0e, 0x29, 0x2e, 0x22, 0x9e, 0x52, 0xaf, 0xd7, 0x01, 0xec, 0xbe, 0x12,
	0x46, 0x6d, 0xf7, 0x66, 0xf6, 0x68, 0x0d, 0xc9, 0x53, 0xf8, 0x8a, 0x62, 0x21, 0x4b, 0xcd, 0xc5,
	0x72, 0x26, 0x34, 0x96, 0x6b, 0x96, 0xd9, 0x86, 0x8e, 0xe8, 0xed, 0x0d, 0x32, 0x85, 0xf1, 0x3b,
	0x99, 0x65, 0xbe, 0xef, 0x8e, 0xf5, 0x6d, 0x9b, 0x49, 0x08, 0xc3, 0x8b, 0x92, 0xa3, 0x48, 0xb3,
	0x8d, 0x15, 0x60, 0x60, 0x05, 0xb8, 0x61, 0x0b, 0x7f, 0x81, 0xb1, 0x27, 0x9b, 0x6d, 0xe6, 0x53,
	0x18, 0x58, 0x50, 0xf7, 0x72, 0xbb, 0xc0, 0x95, 0xcf, 0xf1, 0xbf, 0xfd, 0x5a, 0xc5, 0x39, 0x96,
	0x6b, 0x2c, 0xc9, 0x09, 0x8c, 0x63, 0x5c, 0xf3, 0x04, 0xdf, 0xc9, 0x4f, 0x58, 0x62, 0xfa, 0xa1,
	0x20, 0x0f, 0xfd, 0xa1, 0xe7, 0xae, 0x2e, 0xc5, 0xc5, 0x64, 0x18, 0x55, 0xe3, 0xeb, 0xa3, 0xe4,
	0x29, 0xf9, 0x01, 0xc6, 0xe7, 0x32, 0xcf, 0x99, 0x48, 0x29, 0x26, 0xc8, 0xd7, 0x98, 0x92, 0xc3,
	0xc8, 0x9b, 0xa2, 0x14, 0x55, 0x21, 0x85, 0xc2, 0x56, 0xd8, 0x29, 0x8c, 0x5f, 0xa3, 0xf6, 0x32,
	0x53, 0xa4, 0x9d, 0xb0, 0x9d, 0x78, 0x93, 0x60, 0x5b, 0x19, 0xb6, 0xe0, 0x9f, 0x81, 0xbc, 0x46,
	0xfd, 0x56, 0x2a, 0x6d, 0x98, 0x85, 0x76, 0x57, 0x67, 0xcb, 0xa8, 0x99, 0x6c, 0x95, 0x82, 0xfc,
	0x08, 0x60, 0x87, 0x96, 0x43, 0xde, 0xed, 0xf5, 0x26, 0xd9, 0x1d, 0xa1, 0x2f, 0x61, 0x3c, 0x3f,
	0x3f, 0x35, 0x33, 0xff, 0x9c, 0x65, 0xd9, 0x25, 0x4b, 0x7e, 0x27, 0x5f, 0x47, 0xf5, 0x5f, 0xa0,
	0x36, 0x51, 0x54, 0xab, 0x4c, 0xb7, 0xea, 0x7e, 0x0c, 0x83, 0x0b, 0xfe, 0x79, 0x16, 0x2b, 0x72,
	0xc3, 0x7e, 0x4b, 0x9d, 0x07, 0x8d, 0x3a, 0xea, 0x42, 0x96, 0x4e, 0xfc, 0xbb, 0x1a, 0xd2, 0x7e,
	0xb5, 0x56, 0x9d, 0x17, 0xe6, 0x15, 0xe8, 0xea, 0x89, 0x6c, 0x7f, 0x9a, 0x2d, 0xd2, 0x97, 0x30,
	0x6a, 0x48, 0xcf, 0x36, 0x66, 0x48, 0x6d, 0x91, 0x72, 0xdb, 0x84, 0x38, 0x7b, 0x0c, 0xa1, 0x40,
	0xed, 0x27, 0x57, 0xfd, 0x02, 0xcd, 0x3f, 0xaf, 0x0e, 0xb8, 0x1c, 0xd8, 0xdf, 0xdd, 0x77, 0xff,
	0x05, 0x00, 0x00, 0xff, 0xff, 0x23, 0xce, 0x16, 0x6f, 0xfd, 0x07, 0x00, 0x00,
}
