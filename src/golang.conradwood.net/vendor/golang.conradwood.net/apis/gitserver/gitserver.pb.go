// Code generated by protoc-gen-go.
// source: golang.conradwood.net/apis/gitserver/gitserver.proto
// DO NOT EDIT!

/*
Package gitserver is a generated protocol buffer package.

It is generated from these files:
	golang.conradwood.net/apis/gitserver/gitserver.proto

It has these top-level messages:
	CreateRepoLog
	Build
	RepositoryList
	Permission
	Watchers
	Repository
	GroupRepositoryAccess
	UserRepositoryAccess
	PostReceiveRequest
	PostReceiveStream
	ByIDRequest
	RepositoryInfo
	GitInfo
	CreateRepoRequest
	SourceRepository
	SourceRepositoryURL
	SourceRepositoryList
	SetRepoFlagsRequest
*/
package gitserver

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import common "golang.conradwood.net/apis/common"
import auth "golang.conradwood.net/apis/auth"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// a log and statemachine in the database for creating repos
type CreateRepoLog struct {
	// database id
	ID uint64 `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	// which repo does it refer to?
	RepositoryID uint64 `protobuf:"varint,2,opt,name=RepositoryID" json:"RepositoryID,omitempty"`
	// user who runs this (also in context)
	UserID string `protobuf:"bytes,3,opt,name=UserID" json:"UserID,omitempty"`
	// serialised context
	Context string `protobuf:"bytes,4,opt,name=Context" json:"Context,omitempty"`
	// defines what this 'logentry' does/did. See gitserver source for specifics
	Action uint32 `protobuf:"varint,5,opt,name=Action" json:"Action,omitempty"`
	// true if this succeeded
	Success bool `protobuf:"varint,6,opt,name=Success" json:"Success,omitempty"`
	// if !success, here's the error message
	ErrorMessage     string `protobuf:"bytes,7,opt,name=ErrorMessage" json:"ErrorMessage,omitempty"`
	Started          uint32 `protobuf:"varint,8,opt,name=Started" json:"Started,omitempty"`
	Finished         uint32 `protobuf:"varint,9,opt,name=Finished" json:"Finished,omitempty"`
	AssociationToken string `protobuf:"bytes,10,opt,name=AssociationToken" json:"AssociationToken,omitempty"`
}

func (m *CreateRepoLog) Reset()                    { *m = CreateRepoLog{} }
func (m *CreateRepoLog) String() string            { return proto.CompactTextString(m) }
func (*CreateRepoLog) ProtoMessage()               {}
func (*CreateRepoLog) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *CreateRepoLog) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *CreateRepoLog) GetRepositoryID() uint64 {
	if m != nil {
		return m.RepositoryID
	}
	return 0
}

func (m *CreateRepoLog) GetUserID() string {
	if m != nil {
		return m.UserID
	}
	return ""
}

func (m *CreateRepoLog) GetContext() string {
	if m != nil {
		return m.Context
	}
	return ""
}

func (m *CreateRepoLog) GetAction() uint32 {
	if m != nil {
		return m.Action
	}
	return 0
}

func (m *CreateRepoLog) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

func (m *CreateRepoLog) GetErrorMessage() string {
	if m != nil {
		return m.ErrorMessage
	}
	return ""
}

func (m *CreateRepoLog) GetStarted() uint32 {
	if m != nil {
		return m.Started
	}
	return 0
}

func (m *CreateRepoLog) GetFinished() uint32 {
	if m != nil {
		return m.Finished
	}
	return 0
}

func (m *CreateRepoLog) GetAssociationToken() string {
	if m != nil {
		return m.AssociationToken
	}
	return ""
}

type Build struct {
	ID           uint64 `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	RepositoryID uint64 `protobuf:"varint,2,opt,name=RepositoryID" json:"RepositoryID,omitempty"`
	CommitHash   string `protobuf:"bytes,3,opt,name=CommitHash" json:"CommitHash,omitempty"`
	Branch       string `protobuf:"bytes,4,opt,name=Branch" json:"Branch,omitempty"`
	LogMessage   string `protobuf:"bytes,5,opt,name=LogMessage" json:"LogMessage,omitempty"`
	UserID       string `protobuf:"bytes,6,opt,name=UserID" json:"UserID,omitempty"`
	Timestamp    uint32 `protobuf:"varint,7,opt,name=Timestamp" json:"Timestamp,omitempty"`
	Success      bool   `protobuf:"varint,8,opt,name=Success" json:"Success,omitempty"`
}

func (m *Build) Reset()                    { *m = Build{} }
func (m *Build) String() string            { return proto.CompactTextString(m) }
func (*Build) ProtoMessage()               {}
func (*Build) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Build) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Build) GetRepositoryID() uint64 {
	if m != nil {
		return m.RepositoryID
	}
	return 0
}

func (m *Build) GetCommitHash() string {
	if m != nil {
		return m.CommitHash
	}
	return ""
}

func (m *Build) GetBranch() string {
	if m != nil {
		return m.Branch
	}
	return ""
}

func (m *Build) GetLogMessage() string {
	if m != nil {
		return m.LogMessage
	}
	return ""
}

func (m *Build) GetUserID() string {
	if m != nil {
		return m.UserID
	}
	return ""
}

func (m *Build) GetTimestamp() uint32 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *Build) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

type RepositoryList struct {
	Repos []*Repository `protobuf:"bytes,1,rep,name=Repos" json:"Repos,omitempty"`
}

func (m *RepositoryList) Reset()                    { *m = RepositoryList{} }
func (m *RepositoryList) String() string            { return proto.CompactTextString(m) }
func (*RepositoryList) ProtoMessage()               {}
func (*RepositoryList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *RepositoryList) GetRepos() []*Repository {
	if m != nil {
		return m.Repos
	}
	return nil
}

type Permission struct {
	Read    bool `protobuf:"varint,1,opt,name=Read" json:"Read,omitempty"`
	Write   bool `protobuf:"varint,2,opt,name=Write" json:"Write,omitempty"`
	Execute bool `protobuf:"varint,3,opt,name=Execute" json:"Execute,omitempty"`
	List    bool `protobuf:"varint,4,opt,name=List" json:"List,omitempty"`
}

func (m *Permission) Reset()                    { *m = Permission{} }
func (m *Permission) String() string            { return proto.CompactTextString(m) }
func (*Permission) ProtoMessage()               {}
func (*Permission) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *Permission) GetRead() bool {
	if m != nil {
		return m.Read
	}
	return false
}

func (m *Permission) GetWrite() bool {
	if m != nil {
		return m.Write
	}
	return false
}

func (m *Permission) GetExecute() bool {
	if m != nil {
		return m.Execute
	}
	return false
}

func (m *Permission) GetList() bool {
	if m != nil {
		return m.List
	}
	return false
}

//
// A "watcher" is someone who watches pushes to a given repository.
// Note that pushes by "oneself" will not be notified.
// Otherwise each push will be send via slack
type Watchers struct {
	ID           uint64 `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	UserID       string `protobuf:"bytes,2,opt,name=UserID" json:"UserID,omitempty"`
	RepositoryID uint64 `protobuf:"varint,3,opt,name=RepositoryID" json:"RepositoryID,omitempty"`
	Notifytype   uint32 `protobuf:"varint,4,opt,name=Notifytype" json:"Notifytype,omitempty"`
}

func (m *Watchers) Reset()                    { *m = Watchers{} }
func (m *Watchers) String() string            { return proto.CompactTextString(m) }
func (*Watchers) ProtoMessage()               {}
func (*Watchers) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *Watchers) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Watchers) GetUserID() string {
	if m != nil {
		return m.UserID
	}
	return ""
}

func (m *Watchers) GetRepositoryID() uint64 {
	if m != nil {
		return m.RepositoryID
	}
	return 0
}

func (m *Watchers) GetNotifytype() uint32 {
	if m != nil {
		return m.Notifytype
	}
	return 0
}

type Repository struct {
	ID           uint64      `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	RepoName     string      `protobuf:"bytes,2,opt,name=RepoName" json:"RepoName,omitempty"`
	OwnerID      string      `protobuf:"bytes,3,opt,name=OwnerID" json:"OwnerID,omitempty"`
	ArtefactName string      `protobuf:"bytes,4,opt,name=ArtefactName" json:"ArtefactName,omitempty"`
	Permission   *Permission `protobuf:"bytes,5,opt,name=Permission" json:"Permission,omitempty"`
}

func (m *Repository) Reset()                    { *m = Repository{} }
func (m *Repository) String() string            { return proto.CompactTextString(m) }
func (*Repository) ProtoMessage()               {}
func (*Repository) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *Repository) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Repository) GetRepoName() string {
	if m != nil {
		return m.RepoName
	}
	return ""
}

func (m *Repository) GetOwnerID() string {
	if m != nil {
		return m.OwnerID
	}
	return ""
}

func (m *Repository) GetArtefactName() string {
	if m != nil {
		return m.ArtefactName
	}
	return ""
}

func (m *Repository) GetPermission() *Permission {
	if m != nil {
		return m.Permission
	}
	return nil
}

type GroupRepositoryAccess struct {
	ID      uint64 `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	RepoID  uint64 `protobuf:"varint,2,opt,name=RepoID" json:"RepoID,omitempty"`
	GroupID string `protobuf:"bytes,3,opt,name=GroupID" json:"GroupID,omitempty"`
	Read    bool   `protobuf:"varint,4,opt,name=Read" json:"Read,omitempty"`
	Write   bool   `protobuf:"varint,5,opt,name=Write" json:"Write,omitempty"`
}

func (m *GroupRepositoryAccess) Reset()                    { *m = GroupRepositoryAccess{} }
func (m *GroupRepositoryAccess) String() string            { return proto.CompactTextString(m) }
func (*GroupRepositoryAccess) ProtoMessage()               {}
func (*GroupRepositoryAccess) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *GroupRepositoryAccess) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *GroupRepositoryAccess) GetRepoID() uint64 {
	if m != nil {
		return m.RepoID
	}
	return 0
}

func (m *GroupRepositoryAccess) GetGroupID() string {
	if m != nil {
		return m.GroupID
	}
	return ""
}

func (m *GroupRepositoryAccess) GetRead() bool {
	if m != nil {
		return m.Read
	}
	return false
}

func (m *GroupRepositoryAccess) GetWrite() bool {
	if m != nil {
		return m.Write
	}
	return false
}

type UserRepositoryAccess struct {
	ID     uint64 `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	RepoID uint64 `protobuf:"varint,2,opt,name=RepoID" json:"RepoID,omitempty"`
	UserID string `protobuf:"bytes,3,opt,name=UserID" json:"UserID,omitempty"`
	Read   bool   `protobuf:"varint,4,opt,name=Read" json:"Read,omitempty"`
	Write  bool   `protobuf:"varint,5,opt,name=Write" json:"Write,omitempty"`
}

func (m *UserRepositoryAccess) Reset()                    { *m = UserRepositoryAccess{} }
func (m *UserRepositoryAccess) String() string            { return proto.CompactTextString(m) }
func (*UserRepositoryAccess) ProtoMessage()               {}
func (*UserRepositoryAccess) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *UserRepositoryAccess) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *UserRepositoryAccess) GetRepoID() uint64 {
	if m != nil {
		return m.RepoID
	}
	return 0
}

func (m *UserRepositoryAccess) GetUserID() string {
	if m != nil {
		return m.UserID
	}
	return ""
}

func (m *UserRepositoryAccess) GetRead() bool {
	if m != nil {
		return m.Read
	}
	return false
}

func (m *UserRepositoryAccess) GetWrite() bool {
	if m != nil {
		return m.Write
	}
	return false
}

type PostReceiveRequest struct {
	RepoDirectory string `protobuf:"bytes,1,opt,name=RepoDirectory" json:"RepoDirectory,omitempty"`
	Ref           string `protobuf:"bytes,2,opt,name=Ref" json:"Ref,omitempty"`
	OldRevision   string `protobuf:"bytes,3,opt,name=OldRevision" json:"OldRevision,omitempty"`
	NewRevision   string `protobuf:"bytes,4,opt,name=NewRevision" json:"NewRevision,omitempty"`
}

func (m *PostReceiveRequest) Reset()                    { *m = PostReceiveRequest{} }
func (m *PostReceiveRequest) String() string            { return proto.CompactTextString(m) }
func (*PostReceiveRequest) ProtoMessage()               {}
func (*PostReceiveRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *PostReceiveRequest) GetRepoDirectory() string {
	if m != nil {
		return m.RepoDirectory
	}
	return ""
}

func (m *PostReceiveRequest) GetRef() string {
	if m != nil {
		return m.Ref
	}
	return ""
}

func (m *PostReceiveRequest) GetOldRevision() string {
	if m != nil {
		return m.OldRevision
	}
	return ""
}

func (m *PostReceiveRequest) GetNewRevision() string {
	if m != nil {
		return m.NewRevision
	}
	return ""
}

type PostReceiveStream struct {
}

func (m *PostReceiveStream) Reset()                    { *m = PostReceiveStream{} }
func (m *PostReceiveStream) String() string            { return proto.CompactTextString(m) }
func (*PostReceiveStream) ProtoMessage()               {}
func (*PostReceiveStream) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

type ByIDRequest struct {
	ID uint64 `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
}

func (m *ByIDRequest) Reset()                    { *m = ByIDRequest{} }
func (m *ByIDRequest) String() string            { return proto.CompactTextString(m) }
func (*ByIDRequest) ProtoMessage()               {}
func (*ByIDRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *ByIDRequest) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

type RepositoryInfo struct {
	Repository *Repository `protobuf:"bytes,1,opt,name=Repository" json:"Repository,omitempty"`
}

func (m *RepositoryInfo) Reset()                    { *m = RepositoryInfo{} }
func (m *RepositoryInfo) String() string            { return proto.CompactTextString(m) }
func (*RepositoryInfo) ProtoMessage()               {}
func (*RepositoryInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *RepositoryInfo) GetRepository() *Repository {
	if m != nil {
		return m.Repository
	}
	return nil
}

// this message is passed through the CGI as environment variable back to the builder
type GitInfo struct {
	RepositoryID uint64     `protobuf:"varint,1,opt,name=RepositoryID" json:"RepositoryID,omitempty"`
	UserID       string     `protobuf:"bytes,2,opt,name=UserID" json:"UserID,omitempty"`
	User         *auth.User `protobuf:"bytes,3,opt,name=User" json:"User,omitempty"`
	Version      uint32     `protobuf:"varint,4,opt,name=Version" json:"Version,omitempty"`
}

func (m *GitInfo) Reset()                    { *m = GitInfo{} }
func (m *GitInfo) String() string            { return proto.CompactTextString(m) }
func (*GitInfo) ProtoMessage()               {}
func (*GitInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *GitInfo) GetRepositoryID() uint64 {
	if m != nil {
		return m.RepositoryID
	}
	return 0
}

func (m *GitInfo) GetUserID() string {
	if m != nil {
		return m.UserID
	}
	return ""
}

func (m *GitInfo) GetUser() *auth.User {
	if m != nil {
		return m.User
	}
	return nil
}

func (m *GitInfo) GetVersion() uint32 {
	if m != nil {
		return m.Version
	}
	return 0
}

type CreateRepoRequest struct {
	ArtefactName string               `protobuf:"bytes,1,opt,name=ArtefactName" json:"ArtefactName,omitempty"`
	URL          *SourceRepositoryURL `protobuf:"bytes,2,opt,name=URL" json:"URL,omitempty"`
	Description  string               `protobuf:"bytes,3,opt,name=Description" json:"Description,omitempty"`
}

func (m *CreateRepoRequest) Reset()                    { *m = CreateRepoRequest{} }
func (m *CreateRepoRequest) String() string            { return proto.CompactTextString(m) }
func (*CreateRepoRequest) ProtoMessage()               {}
func (*CreateRepoRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *CreateRepoRequest) GetArtefactName() string {
	if m != nil {
		return m.ArtefactName
	}
	return ""
}

func (m *CreateRepoRequest) GetURL() *SourceRepositoryURL {
	if m != nil {
		return m.URL
	}
	return nil
}

func (m *CreateRepoRequest) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

// stored in database. Maps a URL to a filepath and a unique ID
type SourceRepository struct {
	ID           uint64                 `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	FilePath     string                 `protobuf:"bytes,2,opt,name=FilePath" json:"FilePath,omitempty"`
	URLs         []*SourceRepositoryURL `protobuf:"bytes,3,rep,name=URLs" json:"URLs,omitempty"`
	ArtefactName string                 `protobuf:"bytes,4,opt,name=ArtefactName" json:"ArtefactName,omitempty"`
	// if true: run the post-receive hook
	RunPostReceive bool `protobuf:"varint,5,opt,name=RunPostReceive" json:"RunPostReceive,omitempty"`
	// if true: run the pre-receive hook
	RunPreReceive    bool   `protobuf:"varint,6,opt,name=RunPreReceive" json:"RunPreReceive,omitempty"`
	CreatedComplete  bool   `protobuf:"varint,7,opt,name=CreatedComplete" json:"CreatedComplete,omitempty"`
	Description      string `protobuf:"bytes,8,opt,name=Description" json:"Description,omitempty"`
	UserCommits      uint64 `protobuf:"varint,9,opt,name=UserCommits" json:"UserCommits,omitempty"`
	Deleted          bool   `protobuf:"varint,10,opt,name=Deleted" json:"Deleted,omitempty"`
	DeletedTimestamp uint32 `protobuf:"varint,11,opt,name=DeletedTimestamp" json:"DeletedTimestamp,omitempty"`
	DeleteUser       string `protobuf:"bytes,12,opt,name=DeleteUser" json:"DeleteUser,omitempty"`
	LastCommit       uint32 `protobuf:"varint,13,opt,name=LastCommit" json:"LastCommit,omitempty"`
	LastCommitUser   string `protobuf:"bytes,14,opt,name=LastCommitUser" json:"LastCommitUser,omitempty"`
}

func (m *SourceRepository) Reset()                    { *m = SourceRepository{} }
func (m *SourceRepository) String() string            { return proto.CompactTextString(m) }
func (*SourceRepository) ProtoMessage()               {}
func (*SourceRepository) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *SourceRepository) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *SourceRepository) GetFilePath() string {
	if m != nil {
		return m.FilePath
	}
	return ""
}

func (m *SourceRepository) GetURLs() []*SourceRepositoryURL {
	if m != nil {
		return m.URLs
	}
	return nil
}

func (m *SourceRepository) GetArtefactName() string {
	if m != nil {
		return m.ArtefactName
	}
	return ""
}

func (m *SourceRepository) GetRunPostReceive() bool {
	if m != nil {
		return m.RunPostReceive
	}
	return false
}

func (m *SourceRepository) GetRunPreReceive() bool {
	if m != nil {
		return m.RunPreReceive
	}
	return false
}

func (m *SourceRepository) GetCreatedComplete() bool {
	if m != nil {
		return m.CreatedComplete
	}
	return false
}

func (m *SourceRepository) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *SourceRepository) GetUserCommits() uint64 {
	if m != nil {
		return m.UserCommits
	}
	return 0
}

func (m *SourceRepository) GetDeleted() bool {
	if m != nil {
		return m.Deleted
	}
	return false
}

func (m *SourceRepository) GetDeletedTimestamp() uint32 {
	if m != nil {
		return m.DeletedTimestamp
	}
	return 0
}

func (m *SourceRepository) GetDeleteUser() string {
	if m != nil {
		return m.DeleteUser
	}
	return ""
}

func (m *SourceRepository) GetLastCommit() uint32 {
	if m != nil {
		return m.LastCommit
	}
	return 0
}

func (m *SourceRepository) GetLastCommitUser() string {
	if m != nil {
		return m.LastCommitUser
	}
	return ""
}

// the URL a given repository can be accessed under.
// Note: Repositories may be accessed under multiple different URLs
type SourceRepositoryURL struct {
	ID uint64 `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	// the Repository we're referring to on disk
	V2RepositoryID uint64 `protobuf:"varint,2,opt,name=V2RepositoryID" json:"V2RepositoryID,omitempty"`
	// which Host do we expose this on, e.g. "git.singingcat.net"
	Host string `protobuf:"bytes,3,opt,name=Host" json:"Host,omitempty"`
	// which path do we expose this on, e.g. "/git/foobar.git"
	Path string `protobuf:"bytes,4,opt,name=Path" json:"Path,omitempty"`
}

func (m *SourceRepositoryURL) Reset()                    { *m = SourceRepositoryURL{} }
func (m *SourceRepositoryURL) String() string            { return proto.CompactTextString(m) }
func (*SourceRepositoryURL) ProtoMessage()               {}
func (*SourceRepositoryURL) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *SourceRepositoryURL) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *SourceRepositoryURL) GetV2RepositoryID() uint64 {
	if m != nil {
		return m.V2RepositoryID
	}
	return 0
}

func (m *SourceRepositoryURL) GetHost() string {
	if m != nil {
		return m.Host
	}
	return ""
}

func (m *SourceRepositoryURL) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

type SourceRepositoryList struct {
	Repos []*SourceRepository `protobuf:"bytes,1,rep,name=Repos" json:"Repos,omitempty"`
}

func (m *SourceRepositoryList) Reset()                    { *m = SourceRepositoryList{} }
func (m *SourceRepositoryList) String() string            { return proto.CompactTextString(m) }
func (*SourceRepositoryList) ProtoMessage()               {}
func (*SourceRepositoryList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *SourceRepositoryList) GetRepos() []*SourceRepository {
	if m != nil {
		return m.Repos
	}
	return nil
}

//
// service OLDGIT {
// // deprecated and obsolete: get a repo by ID
// rpc RepoByID(ByIDRequest) returns (RepositoryInfo);
// // deprecated and obsolete: called by git post receive hook
// rpc PostReceive(PostReceiveRequest) returns (stream PostReceiveStream);
// //  deprecated and obsolete: get all repos we got access to
// rpc GetRepos(common.Void) returns (RepositoryList);
// //  deprecated and obsolete: we sometimes hit it badly...
// rpc GetCPULoad(common.Void) returns (common.CPULoad);
// //  deprecated and obsolete: fork a repo, returns ID of new repo
// rpc Fork(ByIDRequest) returns (Repository);
// }
type SetRepoFlagsRequest struct {
	RepoID         uint64 `protobuf:"varint,1,opt,name=RepoID" json:"RepoID,omitempty"`
	RunPostReceive bool   `protobuf:"varint,2,opt,name=RunPostReceive" json:"RunPostReceive,omitempty"`
	RunPreReceive  bool   `protobuf:"varint,3,opt,name=RunPreReceive" json:"RunPreReceive,omitempty"`
}

func (m *SetRepoFlagsRequest) Reset()                    { *m = SetRepoFlagsRequest{} }
func (m *SetRepoFlagsRequest) String() string            { return proto.CompactTextString(m) }
func (*SetRepoFlagsRequest) ProtoMessage()               {}
func (*SetRepoFlagsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *SetRepoFlagsRequest) GetRepoID() uint64 {
	if m != nil {
		return m.RepoID
	}
	return 0
}

func (m *SetRepoFlagsRequest) GetRunPostReceive() bool {
	if m != nil {
		return m.RunPostReceive
	}
	return false
}

func (m *SetRepoFlagsRequest) GetRunPreReceive() bool {
	if m != nil {
		return m.RunPreReceive
	}
	return false
}

func init() {
	proto.RegisterType((*CreateRepoLog)(nil), "gitserver.CreateRepoLog")
	proto.RegisterType((*Build)(nil), "gitserver.Build")
	proto.RegisterType((*RepositoryList)(nil), "gitserver.RepositoryList")
	proto.RegisterType((*Permission)(nil), "gitserver.Permission")
	proto.RegisterType((*Watchers)(nil), "gitserver.Watchers")
	proto.RegisterType((*Repository)(nil), "gitserver.Repository")
	proto.RegisterType((*GroupRepositoryAccess)(nil), "gitserver.GroupRepositoryAccess")
	proto.RegisterType((*UserRepositoryAccess)(nil), "gitserver.UserRepositoryAccess")
	proto.RegisterType((*PostReceiveRequest)(nil), "gitserver.PostReceiveRequest")
	proto.RegisterType((*PostReceiveStream)(nil), "gitserver.PostReceiveStream")
	proto.RegisterType((*ByIDRequest)(nil), "gitserver.ByIDRequest")
	proto.RegisterType((*RepositoryInfo)(nil), "gitserver.RepositoryInfo")
	proto.RegisterType((*GitInfo)(nil), "gitserver.GitInfo")
	proto.RegisterType((*CreateRepoRequest)(nil), "gitserver.CreateRepoRequest")
	proto.RegisterType((*SourceRepository)(nil), "gitserver.SourceRepository")
	proto.RegisterType((*SourceRepositoryURL)(nil), "gitserver.SourceRepositoryURL")
	proto.RegisterType((*SourceRepositoryList)(nil), "gitserver.SourceRepositoryList")
	proto.RegisterType((*SetRepoFlagsRequest)(nil), "gitserver.SetRepoFlagsRequest")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for GIT2 service

type GIT2Client interface {
	// get a repo by ID
	RepoByID(ctx context.Context, in *ByIDRequest, opts ...grpc.CallOption) (*SourceRepository, error)
	// fork a repo, returns ID of new repo
	Fork(ctx context.Context, in *ByIDRequest, opts ...grpc.CallOption) (*Repository, error)
	// get all repos current user got access to. (Note: This is a global list, no longer "per gitserver"
	GetRepos(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*SourceRepositoryList, error)
	// create a new bare git repo
	CreateRepo(ctx context.Context, in *CreateRepoRequest, opts ...grpc.CallOption) (*SourceRepository, error)
	SetRepoFlags(ctx context.Context, in *SetRepoFlagsRequest, opts ...grpc.CallOption) (*common.Void, error)
	// mark this repository as complete. This is limited to repobuilder only
	RepoBuilderComplete(ctx context.Context, in *ByIDRequest, opts ...grpc.CallOption) (*common.Void, error)
	// reset this repository.  This is limited to repobuilder only and specific repositories. It serves to re-use test repositories. It resets the contents to
	// "bare" (but not the URL)
	ResetRepository(ctx context.Context, in *ByIDRequest, opts ...grpc.CallOption) (*common.Void, error)
	// delete a repository. it'll be gone thereafter
	DeleteRepository(ctx context.Context, in *ByIDRequest, opts ...grpc.CallOption) (*common.Void, error)
}

type gIT2Client struct {
	cc *grpc.ClientConn
}

func NewGIT2Client(cc *grpc.ClientConn) GIT2Client {
	return &gIT2Client{cc}
}

func (c *gIT2Client) RepoByID(ctx context.Context, in *ByIDRequest, opts ...grpc.CallOption) (*SourceRepository, error) {
	out := new(SourceRepository)
	err := grpc.Invoke(ctx, "/gitserver.GIT2/RepoByID", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gIT2Client) Fork(ctx context.Context, in *ByIDRequest, opts ...grpc.CallOption) (*Repository, error) {
	out := new(Repository)
	err := grpc.Invoke(ctx, "/gitserver.GIT2/Fork", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gIT2Client) GetRepos(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*SourceRepositoryList, error) {
	out := new(SourceRepositoryList)
	err := grpc.Invoke(ctx, "/gitserver.GIT2/GetRepos", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gIT2Client) CreateRepo(ctx context.Context, in *CreateRepoRequest, opts ...grpc.CallOption) (*SourceRepository, error) {
	out := new(SourceRepository)
	err := grpc.Invoke(ctx, "/gitserver.GIT2/CreateRepo", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gIT2Client) SetRepoFlags(ctx context.Context, in *SetRepoFlagsRequest, opts ...grpc.CallOption) (*common.Void, error) {
	out := new(common.Void)
	err := grpc.Invoke(ctx, "/gitserver.GIT2/SetRepoFlags", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gIT2Client) RepoBuilderComplete(ctx context.Context, in *ByIDRequest, opts ...grpc.CallOption) (*common.Void, error) {
	out := new(common.Void)
	err := grpc.Invoke(ctx, "/gitserver.GIT2/RepoBuilderComplete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gIT2Client) ResetRepository(ctx context.Context, in *ByIDRequest, opts ...grpc.CallOption) (*common.Void, error) {
	out := new(common.Void)
	err := grpc.Invoke(ctx, "/gitserver.GIT2/ResetRepository", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gIT2Client) DeleteRepository(ctx context.Context, in *ByIDRequest, opts ...grpc.CallOption) (*common.Void, error) {
	out := new(common.Void)
	err := grpc.Invoke(ctx, "/gitserver.GIT2/DeleteRepository", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for GIT2 service

type GIT2Server interface {
	// get a repo by ID
	RepoByID(context.Context, *ByIDRequest) (*SourceRepository, error)
	// fork a repo, returns ID of new repo
	Fork(context.Context, *ByIDRequest) (*Repository, error)
	// get all repos current user got access to. (Note: This is a global list, no longer "per gitserver"
	GetRepos(context.Context, *common.Void) (*SourceRepositoryList, error)
	// create a new bare git repo
	CreateRepo(context.Context, *CreateRepoRequest) (*SourceRepository, error)
	SetRepoFlags(context.Context, *SetRepoFlagsRequest) (*common.Void, error)
	// mark this repository as complete. This is limited to repobuilder only
	RepoBuilderComplete(context.Context, *ByIDRequest) (*common.Void, error)
	// reset this repository.  This is limited to repobuilder only and specific repositories. It serves to re-use test repositories. It resets the contents to
	// "bare" (but not the URL)
	ResetRepository(context.Context, *ByIDRequest) (*common.Void, error)
	// delete a repository. it'll be gone thereafter
	DeleteRepository(context.Context, *ByIDRequest) (*common.Void, error)
}

func RegisterGIT2Server(s *grpc.Server, srv GIT2Server) {
	s.RegisterService(&_GIT2_serviceDesc, srv)
}

func _GIT2_RepoByID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ByIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GIT2Server).RepoByID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gitserver.GIT2/RepoByID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GIT2Server).RepoByID(ctx, req.(*ByIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GIT2_Fork_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ByIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GIT2Server).Fork(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gitserver.GIT2/Fork",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GIT2Server).Fork(ctx, req.(*ByIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GIT2_GetRepos_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GIT2Server).GetRepos(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gitserver.GIT2/GetRepos",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GIT2Server).GetRepos(ctx, req.(*common.Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _GIT2_CreateRepo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateRepoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GIT2Server).CreateRepo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gitserver.GIT2/CreateRepo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GIT2Server).CreateRepo(ctx, req.(*CreateRepoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GIT2_SetRepoFlags_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetRepoFlagsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GIT2Server).SetRepoFlags(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gitserver.GIT2/SetRepoFlags",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GIT2Server).SetRepoFlags(ctx, req.(*SetRepoFlagsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GIT2_RepoBuilderComplete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ByIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GIT2Server).RepoBuilderComplete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gitserver.GIT2/RepoBuilderComplete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GIT2Server).RepoBuilderComplete(ctx, req.(*ByIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GIT2_ResetRepository_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ByIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GIT2Server).ResetRepository(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gitserver.GIT2/ResetRepository",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GIT2Server).ResetRepository(ctx, req.(*ByIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GIT2_DeleteRepository_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ByIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GIT2Server).DeleteRepository(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gitserver.GIT2/DeleteRepository",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GIT2Server).DeleteRepository(ctx, req.(*ByIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _GIT2_serviceDesc = grpc.ServiceDesc{
	ServiceName: "gitserver.GIT2",
	HandlerType: (*GIT2Server)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RepoByID",
			Handler:    _GIT2_RepoByID_Handler,
		},
		{
			MethodName: "Fork",
			Handler:    _GIT2_Fork_Handler,
		},
		{
			MethodName: "GetRepos",
			Handler:    _GIT2_GetRepos_Handler,
		},
		{
			MethodName: "CreateRepo",
			Handler:    _GIT2_CreateRepo_Handler,
		},
		{
			MethodName: "SetRepoFlags",
			Handler:    _GIT2_SetRepoFlags_Handler,
		},
		{
			MethodName: "RepoBuilderComplete",
			Handler:    _GIT2_RepoBuilderComplete_Handler,
		},
		{
			MethodName: "ResetRepository",
			Handler:    _GIT2_ResetRepository_Handler,
		},
		{
			MethodName: "DeleteRepository",
			Handler:    _GIT2_DeleteRepository_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "golang.conradwood.net/apis/gitserver/gitserver.proto",
}

func init() {
	proto.RegisterFile("golang.conradwood.net/apis/gitserver/gitserver.proto", fileDescriptor0)
}

var fileDescriptor0 = []byte{
	// 1161 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x9c, 0x57, 0xdd, 0x6e, 0x1b, 0x45,
	0x14, 0xd6, 0xfa, 0x27, 0xd9, 0x1c, 0xc7, 0x69, 0x3a, 0x49, 0xd1, 0xca, 0x94, 0x60, 0xad, 0xaa,
	0xc8, 0x2a, 0x92, 0x0b, 0x86, 0x0a, 0x10, 0x20, 0x94, 0xc4, 0x8d, 0x6b, 0xc9, 0xa4, 0xd1, 0xe4,
	0xa7, 0xd7, 0xcb, 0x7a, 0x62, 0xaf, 0x6a, 0xef, 0x98, 0x99, 0x71, 0xd2, 0x88, 0x0b, 0x2a, 0x71,
	0xc9, 0x0d, 0x2f, 0xd2, 0xa7, 0xe2, 0x05, 0x78, 0x04, 0x34, 0x67, 0x76, 0xbd, 0xb3, 0xb6, 0x63,
	0xd2, 0xde, 0x24, 0x73, 0xbe, 0x39, 0x67, 0xe6, 0xcc, 0x77, 0xfe, 0xbc, 0xf0, 0xcd, 0x80, 0x8f,
	0x82, 0x78, 0xd0, 0x0c, 0x79, 0x2c, 0x82, 0xfe, 0x0d, 0xe7, 0xfd, 0x66, 0xcc, 0xd4, 0xb3, 0x60,
	0x12, 0xc9, 0x67, 0x83, 0x48, 0x49, 0x26, 0xae, 0x99, 0xc8, 0x56, 0xcd, 0x89, 0xe0, 0x8a, 0x93,
	0x8d, 0x19, 0x50, 0x6b, 0xae, 0x38, 0x20, 0xe4, 0xe3, 0x31, 0x8f, 0x93, 0x7f, 0xc6, 0xb4, 0xf6,
	0x74, 0x85, 0x7e, 0x30, 0x55, 0x43, 0xfc, 0x63, 0x74, 0xfd, 0xf7, 0x05, 0xa8, 0x1e, 0x09, 0x16,
	0x28, 0x46, 0xd9, 0x84, 0xf7, 0xf8, 0x80, 0x6c, 0x41, 0xa1, 0xdb, 0xf6, 0x9c, 0xba, 0xd3, 0x28,
	0xd1, 0x42, 0xb7, 0x4d, 0x7c, 0xd8, 0xd4, 0x5b, 0x32, 0x52, 0x5c, 0xdc, 0x76, 0xdb, 0x5e, 0x01,
	0x77, 0x72, 0x18, 0xf9, 0x04, 0xd6, 0x2e, 0x24, 0x13, 0xdd, 0xb6, 0x57, 0xac, 0x3b, 0x8d, 0x0d,
	0x9a, 0x48, 0xc4, 0x83, 0xf5, 0x23, 0x1e, 0x2b, 0xf6, 0x56, 0x79, 0x25, 0xdc, 0x48, 0x45, 0x6d,
	0x71, 0x10, 0xaa, 0x88, 0xc7, 0x5e, 0xb9, 0xee, 0x34, 0xaa, 0x34, 0x91, 0xb4, 0xc5, 0xd9, 0x34,
	0x0c, 0x99, 0x94, 0xde, 0x5a, 0xdd, 0x69, 0xb8, 0x34, 0x15, 0xb5, 0x1f, 0x2f, 0x84, 0xe0, 0xe2,
	0x17, 0x26, 0x65, 0x30, 0x60, 0xde, 0x3a, 0x1e, 0x98, 0xc3, 0xd0, 0x5a, 0x05, 0x42, 0xb1, 0xbe,
	0xe7, 0xe2, 0xb1, 0xa9, 0x48, 0x6a, 0xe0, 0x1e, 0x47, 0x71, 0x24, 0x87, 0xac, 0xef, 0x6d, 0xe0,
	0xd6, 0x4c, 0x26, 0x4f, 0x61, 0xfb, 0x40, 0x4a, 0x1e, 0x46, 0x81, 0x76, 0xe1, 0x9c, 0xbf, 0x61,
	0xb1, 0x07, 0x78, 0xfa, 0x02, 0xee, 0xff, 0xe3, 0x40, 0xf9, 0x70, 0x1a, 0x8d, 0xfa, 0x1f, 0xc5,
	0xd3, 0x1e, 0xc0, 0x11, 0x1f, 0x8f, 0x23, 0xf5, 0x32, 0x90, 0xc3, 0x84, 0x2b, 0x0b, 0xd1, 0xac,
	0x1c, 0x8a, 0x20, 0x0e, 0x87, 0x09, 0x5d, 0x89, 0xa4, 0xed, 0x7a, 0x7c, 0x90, 0xbe, 0xbc, 0x6c,
	0xec, 0x32, 0xc4, 0xe2, 0x7f, 0x2d, 0xc7, 0xff, 0x63, 0xd8, 0x38, 0x8f, 0xc6, 0x4c, 0xaa, 0x60,
	0x3c, 0x41, 0xc2, 0xaa, 0x34, 0x03, 0x6c, 0xae, 0xdd, 0x1c, 0xd7, 0xfe, 0x4f, 0xb0, 0x95, 0xf9,
	0xdd, 0x8b, 0xa4, 0x22, 0x5f, 0x40, 0x19, 0x11, 0xcf, 0xa9, 0x17, 0x1b, 0x95, 0xd6, 0xa3, 0x66,
	0x96, 0xaf, 0x99, 0x26, 0x35, 0x3a, 0x7e, 0x1f, 0xe0, 0x94, 0x89, 0x71, 0x24, 0xa5, 0x0e, 0x29,
	0x81, 0x12, 0x65, 0x41, 0x1f, 0xa9, 0x72, 0x29, 0xae, 0xc9, 0x2e, 0x94, 0x5f, 0x8b, 0x48, 0x31,
	0x64, 0xc9, 0xa5, 0x46, 0xd0, 0x0e, 0xbd, 0x78, 0xcb, 0xc2, 0xa9, 0x62, 0xc8, 0x8d, 0x4b, 0x53,
	0x51, 0x9f, 0xa1, 0xdd, 0x40, 0x5a, 0x5c, 0x8a, 0x6b, 0xff, 0x1a, 0xdc, 0xd7, 0x81, 0x0a, 0x87,
	0x4c, 0xc8, 0x85, 0x60, 0x64, 0x84, 0x14, 0x72, 0x84, 0xcc, 0x07, 0xa9, 0xb8, 0x3c, 0x48, 0x27,
	0x5c, 0x45, 0x57, 0xb7, 0xea, 0x76, 0xc2, 0xf0, 0xc6, 0x2a, 0xb5, 0x10, 0xff, 0xbd, 0x03, 0x90,
	0x19, 0x2c, 0x5c, 0x5d, 0x03, 0x57, 0xef, 0x9e, 0x04, 0x63, 0x96, 0x5c, 0x3e, 0x93, 0xf5, 0x03,
	0x5f, 0xdd, 0xc4, 0x56, 0xa1, 0xa4, 0xa2, 0x76, 0xec, 0x40, 0x28, 0x76, 0x15, 0x84, 0x0a, 0x2d,
	0x4d, 0xfc, 0x73, 0x18, 0x79, 0x6e, 0xd3, 0x8a, 0x59, 0x90, 0x0f, 0x44, 0xb6, 0x49, 0x2d, 0x45,
	0xff, 0x4f, 0x07, 0x1e, 0x75, 0x04, 0x9f, 0x4e, 0x32, 0xa7, 0x0f, 0x4c, 0x49, 0x2d, 0x61, 0x4d,
	0xeb, 0xcc, 0x92, 0x37, 0x91, 0xb4, 0xdb, 0x78, 0x40, 0xe6, 0x76, 0x22, 0xce, 0x62, 0x5b, 0x5a,
	0x16, 0xdb, 0xb2, 0x15, 0x5b, 0xff, 0x9d, 0x03, 0xbb, 0x3a, 0x08, 0x1f, 0xed, 0xc4, 0x5d, 0x3d,
	0xe6, 0xfe, 0x2e, 0xfc, 0xed, 0x00, 0x39, 0xe5, 0x52, 0x51, 0x16, 0xb2, 0xe8, 0x9a, 0x51, 0xf6,
	0xdb, 0x94, 0x49, 0x45, 0x9e, 0x40, 0x55, 0x5f, 0xd1, 0x8e, 0x04, 0x0b, 0xb5, 0x5f, 0xe8, 0xcb,
	0x06, 0xcd, 0x83, 0x64, 0x1b, 0x8a, 0x94, 0x5d, 0x25, 0x11, 0xd5, 0x4b, 0x52, 0x87, 0xca, 0xab,
	0x51, 0x9f, 0xb2, 0xeb, 0x08, 0xe3, 0x61, 0xbc, 0xb2, 0x21, 0xad, 0x71, 0xc2, 0x6e, 0x66, 0x1a,
	0x26, 0xa6, 0x36, 0xe4, 0xef, 0xc0, 0x43, 0xcb, 0xa3, 0x33, 0x25, 0x58, 0x30, 0xf6, 0x3f, 0x83,
	0xca, 0xe1, 0x6d, 0xb7, 0x9d, 0xfa, 0x37, 0x47, 0x90, 0xdf, 0xb1, 0x8b, 0xb3, 0x1b, 0x5f, 0x71,
	0x9d, 0x18, 0x19, 0x82, 0x9a, 0x77, 0x56, 0xa8, 0xa5, 0xe8, 0xff, 0x01, 0xeb, 0x9d, 0x48, 0xe1,
	0x09, 0xf3, 0x75, 0xe1, 0xac, 0x6c, 0xf2, 0xf9, 0x9a, 0xda, 0x83, 0x92, 0x5e, 0x21, 0x01, 0x95,
	0x16, 0x34, 0x71, 0xba, 0x60, 0xa8, 0x11, 0xd7, 0xd9, 0x73, 0xc9, 0xc4, 0x8c, 0x81, 0x2a, 0x4d,
	0x45, 0xff, 0x2f, 0x07, 0x1e, 0x66, 0xc3, 0x27, 0x7d, 0xef, 0x7c, 0x29, 0x38, 0x4b, 0x4a, 0xe1,
	0x4b, 0x28, 0x5e, 0xd0, 0x1e, 0x3a, 0x52, 0x69, 0xed, 0x59, 0x4f, 0x3d, 0xe3, 0x53, 0x11, 0xb2,
	0xcc, 0xef, 0x0b, 0xda, 0xa3, 0x5a, 0x55, 0xc7, 0xa2, 0xcd, 0x64, 0x28, 0xa2, 0x89, 0xb2, 0xa2,
	0x65, 0x41, 0xfe, 0xbb, 0x12, 0x6c, 0xcf, 0x9b, 0x2f, 0xab, 0xee, 0xe3, 0x68, 0xc4, 0x4e, 0x03,
	0x35, 0x4c, 0xab, 0x3b, 0x95, 0x49, 0x0b, 0x4a, 0x17, 0xb4, 0x27, 0xbd, 0x22, 0xb6, 0xc8, 0xff,
	0xf3, 0x0a, 0x75, 0xef, 0x55, 0xf7, 0xfb, 0xb0, 0x45, 0xa7, 0xb1, 0x95, 0x27, 0x49, 0x5a, 0xcf,
	0xa1, 0x98, 0xc8, 0xd3, 0xf8, 0x54, 0xb0, 0x54, 0xcd, 0x4c, 0xd0, 0x3c, 0x48, 0x1a, 0xf0, 0xc0,
	0x70, 0xde, 0x3f, 0xe2, 0xe3, 0xc9, 0x88, 0x29, 0x33, 0x4a, 0x5d, 0x3a, 0x0f, 0xcf, 0x53, 0xe6,
	0x2e, 0x50, 0xa6, 0x35, 0x74, 0x88, 0xcd, 0x04, 0x93, 0x38, 0x58, 0x4b, 0xd4, 0x86, 0x74, 0xf0,
	0xdb, 0x4c, 0x9f, 0xd6, 0xc7, 0x91, 0xea, 0xd2, 0x54, 0xd4, 0x53, 0x37, 0x59, 0x66, 0x23, 0xaa,
	0x82, 0xf9, 0xb1, 0x80, 0xeb, 0x96, 0x6c, 0x30, 0x4c, 0xb4, 0x4d, 0x33, 0xff, 0x32, 0x04, 0xe7,
	0x63, 0x20, 0x95, 0xb9, 0xd4, 0xab, 0x9a, 0x96, 0x9d, 0x21, 0x9a, 0xc1, 0x4c, 0xc2, 0x33, 0xb6,
	0xf0, 0x8c, 0x39, 0xd4, 0x9f, 0xc2, 0xce, 0x92, 0x50, 0x2d, 0x24, 0xc1, 0x3e, 0x6c, 0x5d, 0xb6,
	0x96, 0x0c, 0xfb, 0x39, 0x54, 0xb7, 0xa6, 0x97, 0x5c, 0xaa, 0x24, 0xd9, 0x70, 0xad, 0x31, 0x4c,
	0x1e, 0x13, 0x68, 0x5c, 0xfb, 0x5d, 0xd8, 0x9d, 0xbf, 0x16, 0x87, 0xee, 0x57, 0xf9, 0xa1, 0xfb,
	0xe9, 0x8a, 0x8c, 0x4a, 0x47, 0xef, 0xef, 0xb0, 0x73, 0xc6, 0x94, 0x5e, 0x1f, 0x8f, 0x82, 0x81,
	0x4c, 0x6b, 0x2a, 0x6b, 0xaa, 0x4e, 0xae, 0xa9, 0x2e, 0xa6, 0x56, 0xe1, 0x7e, 0xa9, 0x55, 0x5c,
	0x92, 0x5a, 0xad, 0x7f, 0x8b, 0x50, 0xea, 0x74, 0xcf, 0x5b, 0xe4, 0x67, 0x33, 0x03, 0x0f, 0xb1,
	0x6d, 0x58, 0x5e, 0x5b, 0x6d, 0xad, 0xb6, 0xea, 0x35, 0xe4, 0x39, 0x94, 0x8e, 0xb9, 0x78, 0x73,
	0xa7, 0xf1, 0xf2, 0xee, 0x46, 0xbe, 0x07, 0xb7, 0x63, 0x5e, 0x2f, 0xc9, 0x66, 0x33, 0xf9, 0x51,
	0x7c, 0xc9, 0xa3, 0x7e, 0xed, 0xf3, 0x15, 0xb7, 0x21, 0xd7, 0x1d, 0x80, 0xac, 0x15, 0x91, 0xc7,
	0x96, 0xfa, 0x42, 0x87, 0x5a, 0xed, 0xfa, 0x8f, 0xb0, 0x69, 0x47, 0x80, 0xe4, 0xfa, 0xc0, 0x62,
	0x68, 0x6a, 0x39, 0x3f, 0xc9, 0x0f, 0xb0, 0x83, 0xcc, 0xe9, 0x9f, 0x98, 0x58, 0x45, 0xa6, 0x14,
	0xef, 0xe2, 0x21, 0x6f, 0xfc, 0x2d, 0x3c, 0xa0, 0x4c, 0x26, 0x04, 0x18, 0x6f, 0xee, 0x67, 0xf8,
	0x5d, 0x5a, 0x8b, 0x1f, 0x6a, 0x79, 0xb8, 0x0f, 0x4f, 0x62, 0xa6, 0xec, 0x4f, 0x8d, 0xe4, 0xe3,
	0x43, 0x7f, 0x6d, 0x64, 0x27, 0xfc, 0xba, 0x86, 0x9f, 0x1b, 0x5f, 0xff, 0x17, 0x00, 0x00, 0xff,
	0xff, 0xa8, 0x7d, 0x02, 0x52, 0x0d, 0x0d, 0x00, 0x00,
}
