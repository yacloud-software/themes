// Code generated by protoc-gen-go.
// source: golang.conradwood.net/apis/ipmanager/ipmanager.proto
// DO NOT EDIT!

/*
Package ipmanager is a generated protocol buffer package.

It is generated from these files:
	golang.conradwood.net/apis/ipmanager/ipmanager.proto

It has these top-level messages:
	BindZone
	BindConfig
	BindZones
	DHCPRequest
	DHCPConfig
	LookupRequest
	IPList
	HostAccessRequest
	AccessResponse
	AddDomainRequest
	DomainList
	Domain
	HostList
	Host
	AddHostRequest
	VPNHostList
	VPNHost
	WireguardConfig
	ConfigFile
*/
package ipmanager

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import common "golang.conradwood.net/apis/common"
import objectauth "golang.conradwood.net/apis/objectauth"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type BindZone struct {
	ZoneName string `protobuf:"bytes,1,opt,name=ZoneName" json:"ZoneName,omitempty"`
	Filename string `protobuf:"bytes,2,opt,name=Filename" json:"Filename,omitempty"`
	Content  []byte `protobuf:"bytes,3,opt,name=Content,proto3" json:"Content,omitempty"`
}

func (m *BindZone) Reset()                    { *m = BindZone{} }
func (m *BindZone) String() string            { return proto.CompactTextString(m) }
func (*BindZone) ProtoMessage()               {}
func (*BindZone) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *BindZone) GetZoneName() string {
	if m != nil {
		return m.ZoneName
	}
	return ""
}

func (m *BindZone) GetFilename() string {
	if m != nil {
		return m.Filename
	}
	return ""
}

func (m *BindZone) GetContent() []byte {
	if m != nil {
		return m.Content
	}
	return nil
}

type BindConfig struct {
	Content []byte `protobuf:"bytes,1,opt,name=Content,proto3" json:"Content,omitempty"`
}

func (m *BindConfig) Reset()                    { *m = BindConfig{} }
func (m *BindConfig) String() string            { return proto.CompactTextString(m) }
func (*BindConfig) ProtoMessage()               {}
func (*BindConfig) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *BindConfig) GetContent() []byte {
	if m != nil {
		return m.Content
	}
	return nil
}

type BindZones struct {
	Zones []*BindZone `protobuf:"bytes,1,rep,name=Zones" json:"Zones,omitempty"`
}

func (m *BindZones) Reset()                    { *m = BindZones{} }
func (m *BindZones) String() string            { return proto.CompactTextString(m) }
func (*BindZones) ProtoMessage()               {}
func (*BindZones) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *BindZones) GetZones() []*BindZone {
	if m != nil {
		return m.Zones
	}
	return nil
}

type DHCPRequest struct {
	Cluster string `protobuf:"bytes,1,opt,name=Cluster" json:"Cluster,omitempty"`
}

func (m *DHCPRequest) Reset()                    { *m = DHCPRequest{} }
func (m *DHCPRequest) String() string            { return proto.CompactTextString(m) }
func (*DHCPRequest) ProtoMessage()               {}
func (*DHCPRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *DHCPRequest) GetCluster() string {
	if m != nil {
		return m.Cluster
	}
	return ""
}

type DHCPConfig struct {
	DHCP4Config []byte `protobuf:"bytes,1,opt,name=DHCP4Config,proto3" json:"DHCP4Config,omitempty"`
	DHCP6Config []byte `protobuf:"bytes,2,opt,name=DHCP6Config,proto3" json:"DHCP6Config,omitempty"`
}

func (m *DHCPConfig) Reset()                    { *m = DHCPConfig{} }
func (m *DHCPConfig) String() string            { return proto.CompactTextString(m) }
func (*DHCPConfig) ProtoMessage()               {}
func (*DHCPConfig) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *DHCPConfig) GetDHCP4Config() []byte {
	if m != nil {
		return m.DHCP4Config
	}
	return nil
}

func (m *DHCPConfig) GetDHCP6Config() []byte {
	if m != nil {
		return m.DHCP6Config
	}
	return nil
}

type LookupRequest struct {
	Hostname string `protobuf:"bytes,1,opt,name=Hostname" json:"Hostname,omitempty"`
}

func (m *LookupRequest) Reset()                    { *m = LookupRequest{} }
func (m *LookupRequest) String() string            { return proto.CompactTextString(m) }
func (*LookupRequest) ProtoMessage()               {}
func (*LookupRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *LookupRequest) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

type IPList struct {
	IPAddress []string `protobuf:"bytes,1,rep,name=IPAddress" json:"IPAddress,omitempty"`
}

func (m *IPList) Reset()                    { *m = IPList{} }
func (m *IPList) String() string            { return proto.CompactTextString(m) }
func (*IPList) ProtoMessage()               {}
func (*IPList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *IPList) GetIPAddress() []string {
	if m != nil {
		return m.IPAddress
	}
	return nil
}

type HostAccessRequest struct {
	Host string `protobuf:"bytes,1,opt,name=Host" json:"Host,omitempty"`
}

func (m *HostAccessRequest) Reset()                    { *m = HostAccessRequest{} }
func (m *HostAccessRequest) String() string            { return proto.CompactTextString(m) }
func (*HostAccessRequest) ProtoMessage()               {}
func (*HostAccessRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *HostAccessRequest) GetHost() string {
	if m != nil {
		return m.Host
	}
	return ""
}

type AccessResponse struct {
	Domain   *Domain                  `protobuf:"bytes,1,opt,name=Domain" json:"Domain,omitempty"`
	Response *objectauth.AuthResponse `protobuf:"bytes,2,opt,name=Response" json:"Response,omitempty"`
}

func (m *AccessResponse) Reset()                    { *m = AccessResponse{} }
func (m *AccessResponse) String() string            { return proto.CompactTextString(m) }
func (*AccessResponse) ProtoMessage()               {}
func (*AccessResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *AccessResponse) GetDomain() *Domain {
	if m != nil {
		return m.Domain
	}
	return nil
}

func (m *AccessResponse) GetResponse() *objectauth.AuthResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

type AddDomainRequest struct {
	DomainName string `protobuf:"bytes,1,opt,name=DomainName" json:"DomainName,omitempty"`
}

func (m *AddDomainRequest) Reset()                    { *m = AddDomainRequest{} }
func (m *AddDomainRequest) String() string            { return proto.CompactTextString(m) }
func (*AddDomainRequest) ProtoMessage()               {}
func (*AddDomainRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *AddDomainRequest) GetDomainName() string {
	if m != nil {
		return m.DomainName
	}
	return ""
}

type DomainList struct {
	Domains []*Domain `protobuf:"bytes,1,rep,name=Domains" json:"Domains,omitempty"`
}

func (m *DomainList) Reset()                    { *m = DomainList{} }
func (m *DomainList) String() string            { return proto.CompactTextString(m) }
func (*DomainList) ProtoMessage()               {}
func (*DomainList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *DomainList) GetDomains() []*Domain {
	if m != nil {
		return m.Domains
	}
	return nil
}

type Domain struct {
	ID   uint64 `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	Name string `protobuf:"bytes,2,opt,name=Name" json:"Name,omitempty"`
}

func (m *Domain) Reset()                    { *m = Domain{} }
func (m *Domain) String() string            { return proto.CompactTextString(m) }
func (*Domain) ProtoMessage()               {}
func (*Domain) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *Domain) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Domain) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type HostList struct {
	Hosts []*Host `protobuf:"bytes,1,rep,name=Hosts" json:"Hosts,omitempty"`
}

func (m *HostList) Reset()                    { *m = HostList{} }
func (m *HostList) String() string            { return proto.CompactTextString(m) }
func (*HostList) ProtoMessage()               {}
func (*HostList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *HostList) GetHosts() []*Host {
	if m != nil {
		return m.Hosts
	}
	return nil
}

type Host struct {
	ID     uint64  `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	Domain *Domain `protobuf:"bytes,2,opt,name=Domain" json:"Domain,omitempty"`
	Name   string  `protobuf:"bytes,3,opt,name=Name" json:"Name,omitempty"`
	// if served by yacloud
	ActivelyServing bool `protobuf:"varint,4,opt,name=ActivelyServing" json:"ActivelyServing,omitempty"`
}

func (m *Host) Reset()                    { *m = Host{} }
func (m *Host) String() string            { return proto.CompactTextString(m) }
func (*Host) ProtoMessage()               {}
func (*Host) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *Host) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Host) GetDomain() *Domain {
	if m != nil {
		return m.Domain
	}
	return nil
}

func (m *Host) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Host) GetActivelyServing() bool {
	if m != nil {
		return m.ActivelyServing
	}
	return false
}

type AddHostRequest struct {
	Hostname   string `protobuf:"bytes,1,opt,name=Hostname" json:"Hostname,omitempty"`
	DomainName string `protobuf:"bytes,2,opt,name=DomainName" json:"DomainName,omitempty"`
}

func (m *AddHostRequest) Reset()                    { *m = AddHostRequest{} }
func (m *AddHostRequest) String() string            { return proto.CompactTextString(m) }
func (*AddHostRequest) ProtoMessage()               {}
func (*AddHostRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *AddHostRequest) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

func (m *AddHostRequest) GetDomainName() string {
	if m != nil {
		return m.DomainName
	}
	return ""
}

type VPNHostList struct {
	VPNHosts []*VPNHost `protobuf:"bytes,1,rep,name=VPNHosts" json:"VPNHosts,omitempty"`
}

func (m *VPNHostList) Reset()                    { *m = VPNHostList{} }
func (m *VPNHostList) String() string            { return proto.CompactTextString(m) }
func (*VPNHostList) ProtoMessage()               {}
func (*VPNHostList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *VPNHostList) GetVPNHosts() []*VPNHost {
	if m != nil {
		return m.VPNHosts
	}
	return nil
}

type VPNHost struct {
	// name of host
	Hostname string `protobuf:"bytes,1,opt,name=Hostname" json:"Hostname,omitempty"`
	// do we have a wireguard config?
	Wireguard bool `protobuf:"varint,2,opt,name=Wireguard" json:"Wireguard,omitempty"`
	// do we have an ipsec config?
	IPSec bool `protobuf:"varint,3,opt,name=IPSec" json:"IPSec,omitempty"`
	// do we have an openvpn config?
	OpenVPN bool `protobuf:"varint,4,opt,name=OpenVPN" json:"OpenVPN,omitempty"`
}

func (m *VPNHost) Reset()                    { *m = VPNHost{} }
func (m *VPNHost) String() string            { return proto.CompactTextString(m) }
func (*VPNHost) ProtoMessage()               {}
func (*VPNHost) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *VPNHost) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

func (m *VPNHost) GetWireguard() bool {
	if m != nil {
		return m.Wireguard
	}
	return false
}

func (m *VPNHost) GetIPSec() bool {
	if m != nil {
		return m.IPSec
	}
	return false
}

func (m *VPNHost) GetOpenVPN() bool {
	if m != nil {
		return m.OpenVPN
	}
	return false
}

type WireguardConfig struct {
	Hostname   string `protobuf:"bytes,1,opt,name=Hostname" json:"Hostname,omitempty"`
	Peername   string `protobuf:"bytes,2,opt,name=Peername" json:"Peername,omitempty"`
	PrivateKey string `protobuf:"bytes,3,opt,name=PrivateKey" json:"PrivateKey,omitempty"`
	PublicKey  string `protobuf:"bytes,4,opt,name=PublicKey" json:"PublicKey,omitempty"`
	// IP addresses this host can route to
	IPs         []string      `protobuf:"bytes,5,rep,name=IPs" json:"IPs,omitempty"`
	ConfigFiles []*ConfigFile `protobuf:"bytes,6,rep,name=ConfigFiles" json:"ConfigFiles,omitempty"`
}

func (m *WireguardConfig) Reset()                    { *m = WireguardConfig{} }
func (m *WireguardConfig) String() string            { return proto.CompactTextString(m) }
func (*WireguardConfig) ProtoMessage()               {}
func (*WireguardConfig) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *WireguardConfig) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

func (m *WireguardConfig) GetPeername() string {
	if m != nil {
		return m.Peername
	}
	return ""
}

func (m *WireguardConfig) GetPrivateKey() string {
	if m != nil {
		return m.PrivateKey
	}
	return ""
}

func (m *WireguardConfig) GetPublicKey() string {
	if m != nil {
		return m.PublicKey
	}
	return ""
}

func (m *WireguardConfig) GetIPs() []string {
	if m != nil {
		return m.IPs
	}
	return nil
}

func (m *WireguardConfig) GetConfigFiles() []*ConfigFile {
	if m != nil {
		return m.ConfigFiles
	}
	return nil
}

type ConfigFile struct {
	Filename string `protobuf:"bytes,1,opt,name=Filename" json:"Filename,omitempty"`
	Content  []byte `protobuf:"bytes,2,opt,name=Content,proto3" json:"Content,omitempty"`
}

func (m *ConfigFile) Reset()                    { *m = ConfigFile{} }
func (m *ConfigFile) String() string            { return proto.CompactTextString(m) }
func (*ConfigFile) ProtoMessage()               {}
func (*ConfigFile) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

func (m *ConfigFile) GetFilename() string {
	if m != nil {
		return m.Filename
	}
	return ""
}

func (m *ConfigFile) GetContent() []byte {
	if m != nil {
		return m.Content
	}
	return nil
}

func init() {
	proto.RegisterType((*BindZone)(nil), "ipmanager.BindZone")
	proto.RegisterType((*BindConfig)(nil), "ipmanager.BindConfig")
	proto.RegisterType((*BindZones)(nil), "ipmanager.BindZones")
	proto.RegisterType((*DHCPRequest)(nil), "ipmanager.DHCPRequest")
	proto.RegisterType((*DHCPConfig)(nil), "ipmanager.DHCPConfig")
	proto.RegisterType((*LookupRequest)(nil), "ipmanager.LookupRequest")
	proto.RegisterType((*IPList)(nil), "ipmanager.IPList")
	proto.RegisterType((*HostAccessRequest)(nil), "ipmanager.HostAccessRequest")
	proto.RegisterType((*AccessResponse)(nil), "ipmanager.AccessResponse")
	proto.RegisterType((*AddDomainRequest)(nil), "ipmanager.AddDomainRequest")
	proto.RegisterType((*DomainList)(nil), "ipmanager.DomainList")
	proto.RegisterType((*Domain)(nil), "ipmanager.Domain")
	proto.RegisterType((*HostList)(nil), "ipmanager.HostList")
	proto.RegisterType((*Host)(nil), "ipmanager.Host")
	proto.RegisterType((*AddHostRequest)(nil), "ipmanager.AddHostRequest")
	proto.RegisterType((*VPNHostList)(nil), "ipmanager.VPNHostList")
	proto.RegisterType((*VPNHost)(nil), "ipmanager.VPNHost")
	proto.RegisterType((*WireguardConfig)(nil), "ipmanager.WireguardConfig")
	proto.RegisterType((*ConfigFile)(nil), "ipmanager.ConfigFile")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for IPManagerService service

type IPManagerServiceClient interface {
	// get the zonefiles for bind
	GetBindZones(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*BindZones, error)
	// get the named.conf.local snippet
	GetBindConfig(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*BindConfig, error)
	// get a dhcp server file for a cluster
	GetDHCPConfig(ctx context.Context, in *DHCPRequest, opts ...grpc.CallOption) (*DHCPConfig, error)
	// do a dns->ip lookup (using the local DNS list. useful if you fucked up your /etc/hosts file or do not have dns available
	LookupIP(ctx context.Context, in *LookupRequest, opts ...grpc.CallOption) (*IPList, error)
	// get list of hosts for which we have a VPN configuration
	GetVPNHosts(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*VPNHostList, error)
	// get a wireguard vpn config for a host
	GetWireguardVPNConfig(ctx context.Context, in *VPNHost, opts ...grpc.CallOption) (*WireguardConfig, error)
	// get all domains I have access to
	GetMyDomains(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*DomainList, error)
	// get all hosts hosted and served by the yacloud
	GetHostedHosts(ctx context.Context, in *Domain, opts ...grpc.CallOption) (*HostList, error)
	// add a a host
	AddHostedHost(ctx context.Context, in *AddHostRequest, opts ...grpc.CallOption) (*common.Void, error)
	// add a domain
	AddDomain(ctx context.Context, in *AddDomainRequest, opts ...grpc.CallOption) (*Domain, error)
	// check Host Access (not only domain)
	GetHostAccess(ctx context.Context, in *HostAccessRequest, opts ...grpc.CallOption) (*AccessResponse, error)
}

type iPManagerServiceClient struct {
	cc *grpc.ClientConn
}

func NewIPManagerServiceClient(cc *grpc.ClientConn) IPManagerServiceClient {
	return &iPManagerServiceClient{cc}
}

func (c *iPManagerServiceClient) GetBindZones(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*BindZones, error) {
	out := new(BindZones)
	err := grpc.Invoke(ctx, "/ipmanager.IPManagerService/GetBindZones", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iPManagerServiceClient) GetBindConfig(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*BindConfig, error) {
	out := new(BindConfig)
	err := grpc.Invoke(ctx, "/ipmanager.IPManagerService/GetBindConfig", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iPManagerServiceClient) GetDHCPConfig(ctx context.Context, in *DHCPRequest, opts ...grpc.CallOption) (*DHCPConfig, error) {
	out := new(DHCPConfig)
	err := grpc.Invoke(ctx, "/ipmanager.IPManagerService/GetDHCPConfig", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iPManagerServiceClient) LookupIP(ctx context.Context, in *LookupRequest, opts ...grpc.CallOption) (*IPList, error) {
	out := new(IPList)
	err := grpc.Invoke(ctx, "/ipmanager.IPManagerService/LookupIP", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iPManagerServiceClient) GetVPNHosts(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*VPNHostList, error) {
	out := new(VPNHostList)
	err := grpc.Invoke(ctx, "/ipmanager.IPManagerService/GetVPNHosts", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iPManagerServiceClient) GetWireguardVPNConfig(ctx context.Context, in *VPNHost, opts ...grpc.CallOption) (*WireguardConfig, error) {
	out := new(WireguardConfig)
	err := grpc.Invoke(ctx, "/ipmanager.IPManagerService/GetWireguardVPNConfig", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iPManagerServiceClient) GetMyDomains(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*DomainList, error) {
	out := new(DomainList)
	err := grpc.Invoke(ctx, "/ipmanager.IPManagerService/GetMyDomains", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iPManagerServiceClient) GetHostedHosts(ctx context.Context, in *Domain, opts ...grpc.CallOption) (*HostList, error) {
	out := new(HostList)
	err := grpc.Invoke(ctx, "/ipmanager.IPManagerService/GetHostedHosts", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iPManagerServiceClient) AddHostedHost(ctx context.Context, in *AddHostRequest, opts ...grpc.CallOption) (*common.Void, error) {
	out := new(common.Void)
	err := grpc.Invoke(ctx, "/ipmanager.IPManagerService/AddHostedHost", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iPManagerServiceClient) AddDomain(ctx context.Context, in *AddDomainRequest, opts ...grpc.CallOption) (*Domain, error) {
	out := new(Domain)
	err := grpc.Invoke(ctx, "/ipmanager.IPManagerService/AddDomain", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *iPManagerServiceClient) GetHostAccess(ctx context.Context, in *HostAccessRequest, opts ...grpc.CallOption) (*AccessResponse, error) {
	out := new(AccessResponse)
	err := grpc.Invoke(ctx, "/ipmanager.IPManagerService/GetHostAccess", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for IPManagerService service

type IPManagerServiceServer interface {
	// get the zonefiles for bind
	GetBindZones(context.Context, *common.Void) (*BindZones, error)
	// get the named.conf.local snippet
	GetBindConfig(context.Context, *common.Void) (*BindConfig, error)
	// get a dhcp server file for a cluster
	GetDHCPConfig(context.Context, *DHCPRequest) (*DHCPConfig, error)
	// do a dns->ip lookup (using the local DNS list. useful if you fucked up your /etc/hosts file or do not have dns available
	LookupIP(context.Context, *LookupRequest) (*IPList, error)
	// get list of hosts for which we have a VPN configuration
	GetVPNHosts(context.Context, *common.Void) (*VPNHostList, error)
	// get a wireguard vpn config for a host
	GetWireguardVPNConfig(context.Context, *VPNHost) (*WireguardConfig, error)
	// get all domains I have access to
	GetMyDomains(context.Context, *common.Void) (*DomainList, error)
	// get all hosts hosted and served by the yacloud
	GetHostedHosts(context.Context, *Domain) (*HostList, error)
	// add a a host
	AddHostedHost(context.Context, *AddHostRequest) (*common.Void, error)
	// add a domain
	AddDomain(context.Context, *AddDomainRequest) (*Domain, error)
	// check Host Access (not only domain)
	GetHostAccess(context.Context, *HostAccessRequest) (*AccessResponse, error)
}

func RegisterIPManagerServiceServer(s *grpc.Server, srv IPManagerServiceServer) {
	s.RegisterService(&_IPManagerService_serviceDesc, srv)
}

func _IPManagerService_GetBindZones_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IPManagerServiceServer).GetBindZones(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ipmanager.IPManagerService/GetBindZones",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IPManagerServiceServer).GetBindZones(ctx, req.(*common.Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _IPManagerService_GetBindConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IPManagerServiceServer).GetBindConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ipmanager.IPManagerService/GetBindConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IPManagerServiceServer).GetBindConfig(ctx, req.(*common.Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _IPManagerService_GetDHCPConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DHCPRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IPManagerServiceServer).GetDHCPConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ipmanager.IPManagerService/GetDHCPConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IPManagerServiceServer).GetDHCPConfig(ctx, req.(*DHCPRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IPManagerService_LookupIP_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LookupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IPManagerServiceServer).LookupIP(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ipmanager.IPManagerService/LookupIP",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IPManagerServiceServer).LookupIP(ctx, req.(*LookupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IPManagerService_GetVPNHosts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IPManagerServiceServer).GetVPNHosts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ipmanager.IPManagerService/GetVPNHosts",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IPManagerServiceServer).GetVPNHosts(ctx, req.(*common.Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _IPManagerService_GetWireguardVPNConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VPNHost)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IPManagerServiceServer).GetWireguardVPNConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ipmanager.IPManagerService/GetWireguardVPNConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IPManagerServiceServer).GetWireguardVPNConfig(ctx, req.(*VPNHost))
	}
	return interceptor(ctx, in, info, handler)
}

func _IPManagerService_GetMyDomains_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IPManagerServiceServer).GetMyDomains(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ipmanager.IPManagerService/GetMyDomains",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IPManagerServiceServer).GetMyDomains(ctx, req.(*common.Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _IPManagerService_GetHostedHosts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Domain)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IPManagerServiceServer).GetHostedHosts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ipmanager.IPManagerService/GetHostedHosts",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IPManagerServiceServer).GetHostedHosts(ctx, req.(*Domain))
	}
	return interceptor(ctx, in, info, handler)
}

func _IPManagerService_AddHostedHost_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddHostRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IPManagerServiceServer).AddHostedHost(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ipmanager.IPManagerService/AddHostedHost",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IPManagerServiceServer).AddHostedHost(ctx, req.(*AddHostRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IPManagerService_AddDomain_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddDomainRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IPManagerServiceServer).AddDomain(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ipmanager.IPManagerService/AddDomain",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IPManagerServiceServer).AddDomain(ctx, req.(*AddDomainRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IPManagerService_GetHostAccess_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HostAccessRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IPManagerServiceServer).GetHostAccess(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ipmanager.IPManagerService/GetHostAccess",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IPManagerServiceServer).GetHostAccess(ctx, req.(*HostAccessRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _IPManagerService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "ipmanager.IPManagerService",
	HandlerType: (*IPManagerServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetBindZones",
			Handler:    _IPManagerService_GetBindZones_Handler,
		},
		{
			MethodName: "GetBindConfig",
			Handler:    _IPManagerService_GetBindConfig_Handler,
		},
		{
			MethodName: "GetDHCPConfig",
			Handler:    _IPManagerService_GetDHCPConfig_Handler,
		},
		{
			MethodName: "LookupIP",
			Handler:    _IPManagerService_LookupIP_Handler,
		},
		{
			MethodName: "GetVPNHosts",
			Handler:    _IPManagerService_GetVPNHosts_Handler,
		},
		{
			MethodName: "GetWireguardVPNConfig",
			Handler:    _IPManagerService_GetWireguardVPNConfig_Handler,
		},
		{
			MethodName: "GetMyDomains",
			Handler:    _IPManagerService_GetMyDomains_Handler,
		},
		{
			MethodName: "GetHostedHosts",
			Handler:    _IPManagerService_GetHostedHosts_Handler,
		},
		{
			MethodName: "AddHostedHost",
			Handler:    _IPManagerService_AddHostedHost_Handler,
		},
		{
			MethodName: "AddDomain",
			Handler:    _IPManagerService_AddDomain_Handler,
		},
		{
			MethodName: "GetHostAccess",
			Handler:    _IPManagerService_GetHostAccess_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "golang.conradwood.net/apis/ipmanager/ipmanager.proto",
}

func init() {
	proto.RegisterFile("golang.conradwood.net/apis/ipmanager/ipmanager.proto", fileDescriptor0)
}

var fileDescriptor0 = []byte{
	// 929 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x84, 0x56, 0xdd, 0x6e, 0xe3, 0x44,
	0x14, 0x96, 0xd3, 0x24, 0x75, 0x4e, 0xfa, 0xb7, 0xb3, 0xdb, 0xc5, 0x35, 0x15, 0x8a, 0x2c, 0xe8,
	0x66, 0xb5, 0x92, 0x57, 0xa4, 0x51, 0x16, 0x84, 0x40, 0x4a, 0x5a, 0x91, 0x46, 0x74, 0x83, 0xe5,
	0x95, 0x82, 0x84, 0xb8, 0x71, 0xed, 0x21, 0x6b, 0x48, 0x66, 0xb2, 0xf6, 0xb8, 0xa8, 0xb7, 0x7d,
	0x0a, 0xc4, 0x25, 0xdc, 0xf1, 0x38, 0x3c, 0x11, 0xf2, 0xfc, 0xd8, 0xe3, 0xa4, 0xcd, 0x5e, 0x79,
	0xce, 0x39, 0xdf, 0x99, 0xf9, 0xe6, 0xcc, 0x99, 0xcf, 0x03, 0xfd, 0x39, 0x5d, 0x04, 0x64, 0xee,
	0x86, 0x94, 0x24, 0x41, 0xf4, 0x07, 0xa5, 0x91, 0x4b, 0x30, 0x7b, 0x1d, 0xac, 0xe2, 0xf4, 0x75,
	0xbc, 0x5a, 0x06, 0x24, 0x98, 0xe3, 0xa4, 0x1c, 0xb9, 0xab, 0x84, 0x32, 0x8a, 0x5a, 0x85, 0xc3,
	0x76, 0xb7, 0x4c, 0x10, 0xd2, 0xe5, 0x92, 0x12, 0xf9, 0x11, 0xa9, 0xf6, 0x60, 0x0b, 0x9e, 0xde,
	0xfc, 0x86, 0x43, 0x16, 0x64, 0xec, 0xbd, 0x36, 0x14, 0x79, 0xce, 0x2f, 0x60, 0x8e, 0x62, 0x12,
	0xfd, 0x4c, 0x09, 0x46, 0x36, 0x98, 0xf9, 0x77, 0x1a, 0x2c, 0xb1, 0x65, 0x74, 0x8c, 0x6e, 0xcb,
	0x2f, 0xec, 0x3c, 0xf6, 0x7d, 0xbc, 0xc0, 0x24, 0x8f, 0xd5, 0x44, 0x4c, 0xd9, 0xc8, 0x82, 0xdd,
	0x0b, 0x4a, 0x18, 0x26, 0xcc, 0xda, 0xe9, 0x18, 0xdd, 0x3d, 0x5f, 0x99, 0xce, 0x19, 0x40, 0x3e,
	0xfb, 0x05, 0x25, 0xbf, 0xc6, 0x73, 0x1d, 0x67, 0x54, 0x71, 0x03, 0x68, 0x29, 0x16, 0x29, 0x7a,
	0x09, 0x0d, 0x3e, 0xb0, 0x8c, 0xce, 0x4e, 0xb7, 0xdd, 0x7b, 0xea, 0x96, 0x65, 0x52, 0x20, 0x5f,
	0x20, 0x9c, 0x17, 0xd0, 0xbe, 0xbc, 0xba, 0xf0, 0x7c, 0xfc, 0x21, 0xc3, 0x29, 0xe3, 0x0b, 0x2c,
	0xb2, 0x94, 0xe1, 0x44, 0xf2, 0x57, 0xa6, 0xe3, 0x01, 0xe4, 0x40, 0x49, 0xa4, 0x23, 0xd2, 0xfa,
	0xc2, 0x94, 0x64, 0x74, 0x97, 0x42, 0x0c, 0x24, 0xa2, 0x56, 0x22, 0xa4, 0xcb, 0x79, 0x05, 0xfb,
	0xd7, 0x94, 0xfe, 0x9e, 0xad, 0xd4, 0xe2, 0x36, 0x98, 0x57, 0x34, 0x65, 0x44, 0xab, 0x9e, 0xb2,
	0x9d, 0x33, 0x68, 0x4e, 0xbc, 0xeb, 0x38, 0x65, 0xe8, 0x14, 0x5a, 0x13, 0x6f, 0x18, 0x45, 0x09,
	0x4e, 0xc5, 0x06, 0x5b, 0x7e, 0xe9, 0x70, 0x5e, 0xc0, 0x93, 0x3c, 0x67, 0x18, 0x86, 0x38, 0x4d,
	0xd5, 0xc4, 0x08, 0xea, 0xb9, 0x53, 0x4e, 0xca, 0xc7, 0xce, 0x07, 0x38, 0x50, 0xa0, 0x74, 0x45,
	0x49, 0x8a, 0xd1, 0x4b, 0x68, 0x5e, 0xd2, 0x65, 0x10, 0x13, 0x8e, 0x6b, 0xf7, 0x9e, 0x68, 0x65,
	0x13, 0x01, 0x5f, 0x02, 0x50, 0x1f, 0x4c, 0x95, 0xc6, 0x77, 0xd6, 0xee, 0x59, 0xae, 0xd6, 0x18,
	0xc3, 0x8c, 0xbd, 0x57, 0x71, 0xbf, 0x40, 0x3a, 0x3d, 0x38, 0x1a, 0x46, 0x91, 0x9c, 0x4a, 0x52,
	0xfb, 0x0c, 0x40, 0x38, 0xb4, 0x9e, 0xd1, 0x3c, 0xce, 0xd7, 0x2a, 0xce, 0xf7, 0xfe, 0x0a, 0x76,
	0x85, 0xa5, 0x8e, 0xf6, 0x01, 0x8e, 0x0a, 0xe1, 0x0c, 0xd4, 0x7e, 0xd0, 0x01, 0xd4, 0x26, 0x97,
	0x7c, 0xf2, 0xba, 0x5f, 0x9b, 0x5c, 0xa2, 0x53, 0xa8, 0x4f, 0x8b, 0x36, 0x1c, 0x99, 0xff, 0xde,
	0x9f, 0xd4, 0x59, 0x92, 0x61, 0x9f, 0x7b, 0x9d, 0x2f, 0xc5, 0x31, 0xf0, 0x05, 0xbf, 0x80, 0x46,
	0x3e, 0x56, 0xcb, 0x1d, 0x6a, 0xcb, 0xe5, 0x7e, 0x5f, 0x44, 0x9d, 0x3f, 0x0d, 0x51, 0xe1, 0x8d,
	0x95, 0x46, 0x45, 0x4d, 0x6b, 0x8f, 0xd4, 0x74, 0xf4, 0xc9, 0x5f, 0xf7, 0x27, 0xcd, 0x2c, 0x26,
	0x6c, 0xd0, 0xff, 0xfb, 0xfe, 0xa4, 0x15, 0x71, 0xaf, 0x1b, 0x47, 0x45, 0xb1, 0x91, 0x64, 0xbb,
	0x23, 0x4e, 0x8f, 0x5f, 0xa6, 0x2e, 0x1c, 0x0e, 0x43, 0x16, 0xdf, 0xe2, 0xc5, 0xdd, 0x3b, 0x9c,
	0xdc, 0xc6, 0x64, 0x6e, 0xd5, 0x3b, 0x46, 0xd7, 0xf4, 0xd7, 0xdd, 0xce, 0x35, 0x1c, 0x0c, 0xa3,
	0x88, 0x93, 0xfd, 0x78, 0x9b, 0xad, 0x1d, 0x47, 0x6d, 0xe3, 0x38, 0xbe, 0x85, 0xf6, 0xcc, 0x9b,
	0x16, 0xe5, 0x71, 0xc1, 0x94, 0xa6, 0xaa, 0x10, 0xd2, 0x36, 0x28, 0x43, 0x7e, 0x81, 0x71, 0x52,
	0xd8, 0x95, 0xe3, 0xad, 0x2c, 0x4e, 0xa1, 0xf5, 0x53, 0x9c, 0xe0, 0x79, 0x16, 0x24, 0x11, 0x27,
	0x61, 0xfa, 0xa5, 0x03, 0x3d, 0x83, 0xc6, 0xc4, 0x7b, 0x87, 0x43, 0x5e, 0x10, 0xd3, 0x17, 0x46,
	0x7e, 0x73, 0x7f, 0x5c, 0x61, 0x32, 0xf3, 0xa6, 0xb2, 0x12, 0xca, 0x74, 0xfe, 0x33, 0xe0, 0xb0,
	0xc8, 0x96, 0xb7, 0x73, 0xdb, 0xea, 0x36, 0x98, 0x1e, 0xc6, 0x89, 0x2e, 0x54, 0xca, 0xce, 0xeb,
	0xe3, 0x25, 0xf1, 0x6d, 0xc0, 0xf0, 0x0f, 0xf8, 0x4e, 0x9e, 0x88, 0xe6, 0xc9, 0x99, 0x7b, 0xd9,
	0xcd, 0x22, 0x0e, 0xf3, 0x70, 0x9d, 0x87, 0x4b, 0x07, 0x3a, 0x82, 0x9d, 0x89, 0x97, 0x5a, 0x0d,
	0x7e, 0x69, 0xf3, 0x21, 0x7a, 0x03, 0x6d, 0xc1, 0x28, 0x97, 0xc2, 0xd4, 0x6a, 0xf2, 0x1a, 0x1e,
	0x6b, 0x35, 0x2c, 0xa3, 0xbe, 0x8e, 0x74, 0x46, 0x00, 0xa5, 0x59, 0xd1, 0x56, 0xe3, 0x71, 0x6d,
	0xad, 0x55, 0x34, 0xb3, 0xf7, 0x4f, 0x03, 0x8e, 0x26, 0xde, 0x5b, 0xb1, 0x12, 0xef, 0x97, 0x10,
	0xa3, 0x1e, 0xec, 0x8d, 0x31, 0x2b, 0xb5, 0x74, 0xcf, 0x95, 0x7f, 0x89, 0x19, 0x8d, 0x23, 0xfb,
	0xd9, 0x03, 0x52, 0x9a, 0xa2, 0x3e, 0xec, 0xcb, 0x1c, 0x59, 0xde, 0x6a, 0xd2, 0xf1, 0x5a, 0x92,
	0x04, 0x7d, 0xc7, 0xb3, 0x34, 0x51, 0x7d, 0xae, 0x5f, 0x8e, 0x52, 0x94, 0x2b, 0xf9, 0x1a, 0xfc,
	0x0d, 0x98, 0x42, 0x3f, 0x27, 0x1e, 0xb2, 0x34, 0x48, 0x45, 0x54, 0x6d, 0xfd, 0xc6, 0x49, 0x05,
	0x3d, 0x87, 0xf6, 0x18, 0x33, 0xd5, 0x94, 0x6b, 0x64, 0x9f, 0x6f, 0x36, 0x30, 0x4f, 0x1a, 0xc3,
	0xf1, 0x18, 0xb3, 0xa2, 0x8f, 0x66, 0xde, 0x54, 0xd2, 0x78, 0xa0, 0xe3, 0x6d, 0x5b, 0xf3, 0xad,
	0xb7, 0xde, 0x39, 0x2f, 0xf0, 0xdb, 0x3b, 0x29, 0x53, 0x5b, 0x6a, 0xa5, 0x09, 0xdf, 0x57, 0x70,
	0x30, 0xc6, 0x2c, 0x9f, 0x1b, 0x47, 0x82, 0xf5, 0xa6, 0x92, 0xd8, 0x4f, 0xd7, 0xd4, 0x49, 0x66,
	0xee, 0xcb, 0xfb, 0x2f, 0x32, 0xd1, 0x89, 0x86, 0xaa, 0x2a, 0x83, 0x5d, 0xa1, 0x82, 0xbe, 0x81,
	0x56, 0x21, 0xd7, 0xe8, 0xd3, 0x6a, 0x56, 0x45, 0xc4, 0xed, 0x4d, 0x2e, 0xe8, 0x8a, 0x1f, 0x6e,
	0xf9, 0x2b, 0x42, 0xa7, 0x6b, 0xe4, 0x2a, 0x7f, 0x28, 0xbb, 0x42, 0xaa, 0xf2, 0x5b, 0x1a, 0x9d,
	0xc1, 0xe7, 0x04, 0x33, 0xfd, 0x59, 0x22, 0x1f, 0x2a, 0xf9, 0xcb, 0xa4, 0x4c, 0xbb, 0x69, 0xf2,
	0xe7, 0xc8, 0xf9, 0xff, 0x01, 0x00, 0x00, 0xff, 0xff, 0xc7, 0xe8, 0xa4, 0xa6, 0x39, 0x09, 0x00,
	0x00,
}
